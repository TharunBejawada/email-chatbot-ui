import {
  decode,
  decodePath,
  getQuery,
  joinURL,
  parseURL,
  withLeadingSlash,
  withoutBase,
  withoutTrailingSlash
} from "./chunk-S3POJQT2.js";
import {
  __publicField
} from "./chunk-V6TY7KAL.js";

// node_modules/.pnpm/cookie-es@1.2.2/node_modules/cookie-es/dist/index.mjs
function parse(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  const obj = {};
  const opt = options || {};
  const dec = opt.decode || decode2;
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if ((opt == null ? void 0 : opt.filter) && !(opt == null ? void 0 : opt.filter(key))) {
      index = endIdx + 1;
      continue;
    }
    if (void 0 === obj[key]) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.codePointAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
}
function decode2(str) {
  return str.includes("%") ? decodeURIComponent(str) : str;
}
function tryDecode(str, decode22) {
  try {
    return decode22(str);
  } catch {
    return str;
  }
}
var fieldContentRegExp = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function serialize(name, value, options) {
  const opt = options || {};
  const enc = opt.encode || encodeURIComponent;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  const encodedValue = enc(value);
  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {
    throw new TypeError("argument val is invalid");
  }
  let str = name + "=" + encodedValue;
  if (void 0 !== opt.maxAge && opt.maxAge !== null) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (!isDate(opt.expires) || Number.isNaN(opt.expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    const priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low": {
        str += "; Priority=Low";
        break;
      }
      case "medium": {
        str += "; Priority=Medium";
        break;
      }
      case "high": {
        str += "; Priority=High";
        break;
      }
      default: {
        throw new TypeError("option priority is invalid");
      }
    }
  }
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true: {
        str += "; SameSite=Strict";
        break;
      }
      case "lax": {
        str += "; SameSite=Lax";
        break;
      }
      case "strict": {
        str += "; SameSite=Strict";
        break;
      }
      case "none": {
        str += "; SameSite=None";
        break;
      }
      default: {
        throw new TypeError("option sameSite is invalid");
      }
    }
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  return str;
}
function isDate(val) {
  return Object.prototype.toString.call(val) === "[object Date]" || val instanceof Date;
}
function parseSetCookie(setCookieValue, options) {
  const parts = (setCookieValue || "").split(";").filter((str) => typeof str === "string" && !!str.trim());
  const nameValuePairStr = parts.shift() || "";
  const parsed = _parseNameValuePair(nameValuePairStr);
  const name = parsed.name;
  let value = parsed.value;
  try {
    value = (options == null ? void 0 : options.decode) === false ? value : ((options == null ? void 0 : options.decode) || decodeURIComponent)(value);
  } catch {
  }
  const cookie = {
    name,
    value
  };
  for (const part of parts) {
    const sides = part.split("=");
    const partKey = (sides.shift() || "").trimStart().toLowerCase();
    const partValue = sides.join("=");
    switch (partKey) {
      case "expires": {
        cookie.expires = new Date(partValue);
        break;
      }
      case "max-age": {
        cookie.maxAge = Number.parseInt(partValue, 10);
        break;
      }
      case "secure": {
        cookie.secure = true;
        break;
      }
      case "httponly": {
        cookie.httpOnly = true;
        break;
      }
      case "samesite": {
        cookie.sameSite = partValue;
        break;
      }
      default: {
        cookie[partKey] = partValue;
      }
    }
  }
  return cookie;
}
function _parseNameValuePair(nameValuePairStr) {
  let name = "";
  let value = "";
  const nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name, value };
}

// node_modules/.pnpm/radix3@1.1.2/node_modules/radix3/dist/index.mjs
var NODE_TYPES = {
  NORMAL: 0,
  WILDCARD: 1,
  PLACEHOLDER: 2
};
function createRouter(options = {}) {
  const ctx = {
    options,
    rootNode: createRadixNode(),
    staticRoutesMap: {}
  };
  const normalizeTrailingSlash = (p3) => options.strictTrailingSlash ? p3 : p3.replace(/\/$/, "") || "/";
  if (options.routes) {
    for (const path in options.routes) {
      insert(ctx, normalizeTrailingSlash(path), options.routes[path]);
    }
  }
  return {
    ctx,
    lookup: (path) => lookup(ctx, normalizeTrailingSlash(path)),
    insert: (path, data) => insert(ctx, normalizeTrailingSlash(path), data),
    remove: (path) => remove(ctx, normalizeTrailingSlash(path))
  };
}
function lookup(ctx, path) {
  const staticPathNode = ctx.staticRoutesMap[path];
  if (staticPathNode) {
    return staticPathNode.data;
  }
  const sections = path.split("/");
  const params = {};
  let paramsFound = false;
  let wildcardNode = null;
  let node = ctx.rootNode;
  let wildCardParam = null;
  for (let i2 = 0; i2 < sections.length; i2++) {
    const section = sections[i2];
    if (node.wildcardChildNode !== null) {
      wildcardNode = node.wildcardChildNode;
      wildCardParam = sections.slice(i2).join("/");
    }
    const nextNode = node.children.get(section);
    if (nextNode === void 0) {
      if (node && node.placeholderChildren.length > 1) {
        const remaining = sections.length - i2;
        node = node.placeholderChildren.find((c2) => c2.maxDepth === remaining) || null;
      } else {
        node = node.placeholderChildren[0] || null;
      }
      if (!node) {
        break;
      }
      if (node.paramName) {
        params[node.paramName] = section;
      }
      paramsFound = true;
    } else {
      node = nextNode;
    }
  }
  if ((node === null || node.data === null) && wildcardNode !== null) {
    node = wildcardNode;
    params[node.paramName || "_"] = wildCardParam;
    paramsFound = true;
  }
  if (!node) {
    return null;
  }
  if (paramsFound) {
    return {
      ...node.data,
      params: paramsFound ? params : void 0
    };
  }
  return node.data;
}
function insert(ctx, path, data) {
  let isStaticRoute = true;
  const sections = path.split("/");
  let node = ctx.rootNode;
  let _unnamedPlaceholderCtr = 0;
  const matchedNodes = [node];
  for (const section of sections) {
    let childNode;
    if (childNode = node.children.get(section)) {
      node = childNode;
    } else {
      const type = getNodeType(section);
      childNode = createRadixNode({ type, parent: node });
      node.children.set(section, childNode);
      if (type === NODE_TYPES.PLACEHOLDER) {
        childNode.paramName = section === "*" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);
        node.placeholderChildren.push(childNode);
        isStaticRoute = false;
      } else if (type === NODE_TYPES.WILDCARD) {
        node.wildcardChildNode = childNode;
        childNode.paramName = section.slice(
          3
          /* "**:" */
        ) || "_";
        isStaticRoute = false;
      }
      matchedNodes.push(childNode);
      node = childNode;
    }
  }
  for (const [depth, node2] of matchedNodes.entries()) {
    node2.maxDepth = Math.max(matchedNodes.length - depth, node2.maxDepth || 0);
  }
  node.data = data;
  if (isStaticRoute === true) {
    ctx.staticRoutesMap[path] = node;
  }
  return node;
}
function remove(ctx, path) {
  let success = false;
  const sections = path.split("/");
  let node = ctx.rootNode;
  for (const section of sections) {
    node = node.children.get(section);
    if (!node) {
      return success;
    }
  }
  if (node.data) {
    const lastSection = sections.at(-1) || "";
    node.data = null;
    if (Object.keys(node.children).length === 0 && node.parent) {
      node.parent.children.delete(lastSection);
      node.parent.wildcardChildNode = null;
      node.parent.placeholderChildren = [];
    }
    success = true;
  }
  return success;
}
function createRadixNode(options = {}) {
  return {
    type: options.type || NODE_TYPES.NORMAL,
    maxDepth: 0,
    parent: options.parent || null,
    children: /* @__PURE__ */ new Map(),
    data: options.data || null,
    paramName: options.paramName || null,
    wildcardChildNode: null,
    placeholderChildren: []
  };
}
function getNodeType(str) {
  if (str.startsWith("**")) {
    return NODE_TYPES.WILDCARD;
  }
  if (str[0] === ":" || str === "*") {
    return NODE_TYPES.PLACEHOLDER;
  }
  return NODE_TYPES.NORMAL;
}
function toRouteMatcher(router) {
  const table = _routerNodeToTable("", router.ctx.rootNode);
  return _createMatcher(table, router.ctx.options.strictTrailingSlash);
}
function _createMatcher(table, strictTrailingSlash) {
  return {
    ctx: { table },
    matchAll: (path) => _matchRoutes(path, table, strictTrailingSlash)
  };
}
function _createRouteTable() {
  return {
    static: /* @__PURE__ */ new Map(),
    wildcard: /* @__PURE__ */ new Map(),
    dynamic: /* @__PURE__ */ new Map()
  };
}
function _matchRoutes(path, table, strictTrailingSlash) {
  if (strictTrailingSlash !== true && path.endsWith("/")) {
    path = path.slice(0, -1) || "/";
  }
  const matches = [];
  for (const [key, value] of _sortRoutesMap(table.wildcard)) {
    if (path === key || path.startsWith(key + "/")) {
      matches.push(value);
    }
  }
  for (const [key, value] of _sortRoutesMap(table.dynamic)) {
    if (path.startsWith(key + "/")) {
      const subPath = "/" + path.slice(key.length).split("/").splice(2).join("/");
      matches.push(..._matchRoutes(subPath, value));
    }
  }
  const staticMatch = table.static.get(path);
  if (staticMatch) {
    matches.push(staticMatch);
  }
  return matches.filter(Boolean);
}
function _sortRoutesMap(m4) {
  return [...m4.entries()].sort((a, b3) => a[0].length - b3[0].length);
}
function _routerNodeToTable(initialPath, initialNode) {
  const table = _createRouteTable();
  function _addNode(path, node) {
    if (path) {
      if (node.type === NODE_TYPES.NORMAL && !(path.includes("*") || path.includes(":"))) {
        if (node.data) {
          table.static.set(path, node.data);
        }
      } else if (node.type === NODE_TYPES.WILDCARD) {
        table.wildcard.set(path.replace("/**", ""), node.data);
      } else if (node.type === NODE_TYPES.PLACEHOLDER) {
        const subTable = _routerNodeToTable("", node);
        if (node.data) {
          subTable.static.set("/", node.data);
        }
        table.dynamic.set(path.replace(/\/\*|\/:\w+/, ""), subTable);
        return;
      }
    }
    for (const [childPath, child] of node.children.entries()) {
      _addNode(`${path}/${childPath}`.replace("//", "/"), child);
    }
  }
  _addNode(initialPath, initialNode);
  return table;
}

// node_modules/.pnpm/destr@2.0.5/node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/.pnpm/defu@6.1.4/node_modules/defu/dist/defu.mjs
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults2, namespace = ".", merger) {
  if (!isPlainObject(defaults2)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults2);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p3, c2) => _defu(p3, c2, "", merger), {})
  );
}
var defu = createDefu();
var defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});
var defuArrayFn = createDefu((object, key, currentValue) => {
  if (Array.isArray(object[key]) && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

// node_modules/.pnpm/uncrypto@0.1.3/node_modules/uncrypto/dist/crypto.web.mjs
var webCrypto = globalThis.crypto;
var subtle = webCrypto.subtle;
var randomUUID = () => {
  return webCrypto.randomUUID();
};
var getRandomValues = (array) => {
  return webCrypto.getRandomValues(array);
};
var _crypto = {
  randomUUID,
  getRandomValues,
  subtle
};

// node_modules/.pnpm/iron-webcrypto@1.2.1/node_modules/iron-webcrypto/dist/index.js
var alphabetByEncoding = {};
var alphabetByValue = Array.from({ length: 64 });
for (let i2 = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  alphabetByEncoding[char] = i2;
  alphabetByValue[i2] = char;
}
for (let i2 = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  const index = i2 + 26;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
for (let i2 = 0; i2 < 10; i2++) {
  alphabetByEncoding[i2.toString(10)] = i2 + 52;
  const char = i2.toString(10);
  const index = i2 + 52;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
alphabetByEncoding["-"] = 62;
alphabetByValue[62] = "-";
alphabetByEncoding["_"] = 63;
alphabetByValue[63] = "_";
var bitsPerLetter = 6;
var bitsPerByte = 8;
var maxLetterValue = 63;
var stringToBuffer = (value) => {
  return new TextEncoder().encode(value);
};
var bufferToString = (value) => {
  return new TextDecoder().decode(value);
};
var base64urlDecode = (_input) => {
  const input = _input + "=".repeat((4 - _input.length % 4) % 4);
  let totalByteLength = input.length / 4 * 3;
  if (input.endsWith("==")) {
    totalByteLength -= 2;
  } else if (input.endsWith("=")) {
    totalByteLength--;
  }
  const out = new ArrayBuffer(totalByteLength);
  const dataView = new DataView(out);
  for (let i2 = 0; i2 < input.length; i2 += 4) {
    let bits = 0;
    let bitLength = 0;
    for (let j3 = i2, limit = i2 + 3; j3 <= limit; j3++) {
      if (input[j3] === "=") {
        bits >>= bitsPerLetter;
      } else {
        if (!(input[j3] in alphabetByEncoding)) {
          throw new TypeError(`Invalid character ${input[j3]} in base64 string.`);
        }
        bits |= alphabetByEncoding[input[j3]] << (limit - j3) * bitsPerLetter;
        bitLength += bitsPerLetter;
      }
    }
    const chunkOffset = i2 / 4 * 3;
    bits >>= bitLength % bitsPerByte;
    const byteLength = Math.floor(bitLength / bitsPerByte);
    for (let k3 = 0; k3 < byteLength; k3++) {
      const offset = (byteLength - k3 - 1) * bitsPerByte;
      dataView.setUint8(chunkOffset + k3, (bits & 255 << offset) >> offset);
    }
  }
  return new Uint8Array(out);
};
var base64urlEncode = (_input) => {
  const input = typeof _input === "string" ? stringToBuffer(_input) : _input;
  let str = "";
  for (let i2 = 0; i2 < input.length; i2 += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j3 = i2, limit = Math.min(i2 + 3, input.length); j3 < limit; j3++) {
      bits |= input[j3] << (limit - j3 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k3 = 1; k3 <= bitClusterCount; k3++) {
      const offset = (bitClusterCount - k3) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
    }
  }
  return str;
};
var defaults = {
  encryption: { saltBits: 256, algorithm: "aes-256-cbc", iterations: 1, minPasswordlength: 32 },
  integrity: { saltBits: 256, algorithm: "sha256", iterations: 1, minPasswordlength: 32 },
  ttl: 0,
  timestampSkewSec: 60,
  localtimeOffsetMsec: 0
};
var clone = (options) => ({
  ...options,
  encryption: { ...options.encryption },
  integrity: { ...options.integrity }
});
var algorithms = {
  "aes-128-ctr": { keyBits: 128, ivBits: 128, name: "AES-CTR" },
  "aes-256-cbc": { keyBits: 256, ivBits: 128, name: "AES-CBC" },
  sha256: { keyBits: 256, name: "SHA-256" }
};
var macPrefix = "Fe26.2";
var randomBytes = (_crypto2, size) => {
  const bytes = new Uint8Array(size);
  _crypto2.getRandomValues(bytes);
  return bytes;
};
var randomBits = (_crypto2, bits) => {
  if (bits < 1)
    throw new Error("Invalid random bits count");
  const bytes = Math.ceil(bits / 8);
  return randomBytes(_crypto2, bytes);
};
var pbkdf2 = async (_crypto2, password, salt, iterations, keyLength, hash) => {
  const passwordBuffer = stringToBuffer(password);
  const importedKey = await _crypto2.subtle.importKey(
    "raw",
    passwordBuffer,
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );
  const saltBuffer = stringToBuffer(salt);
  const params = { name: "PBKDF2", hash, salt: saltBuffer, iterations };
  const derivation = await _crypto2.subtle.deriveBits(params, importedKey, keyLength * 8);
  return derivation;
};
var generateKey = async (_crypto2, password, options) => {
  var _a2;
  if (!(password == null ? void 0 : password.length))
    throw new Error("Empty password");
  if (options == null || typeof options !== "object")
    throw new Error("Bad options");
  if (!(options.algorithm in algorithms))
    throw new Error(`Unknown algorithm: ${options.algorithm}`);
  const algorithm = algorithms[options.algorithm];
  const result = {};
  const hmac = (_a2 = options.hmac) != null ? _a2 : false;
  const id = hmac ? { name: "HMAC", hash: algorithm.name } : { name: algorithm.name };
  const usage = hmac ? ["sign", "verify"] : ["encrypt", "decrypt"];
  if (typeof password === "string") {
    if (password.length < options.minPasswordlength)
      throw new Error(
        `Password string too short (min ${options.minPasswordlength} characters required)`
      );
    let { salt = "" } = options;
    if (!salt) {
      const { saltBits = 0 } = options;
      if (!saltBits)
        throw new Error("Missing salt and saltBits options");
      const randomSalt = randomBits(_crypto2, saltBits);
      salt = [...new Uint8Array(randomSalt)].map((x2) => x2.toString(16).padStart(2, "0")).join("");
    }
    const derivedKey = await pbkdf2(
      _crypto2,
      password,
      salt,
      options.iterations,
      algorithm.keyBits / 8,
      "SHA-1"
    );
    const importedEncryptionKey = await _crypto2.subtle.importKey(
      "raw",
      derivedKey,
      id,
      false,
      usage
    );
    result.key = importedEncryptionKey;
    result.salt = salt;
  } else {
    if (password.length < algorithm.keyBits / 8)
      throw new Error("Key buffer (password) too small");
    result.key = await _crypto2.subtle.importKey("raw", password, id, false, usage);
    result.salt = "";
  }
  if (options.iv)
    result.iv = options.iv;
  else if ("ivBits" in algorithm)
    result.iv = randomBits(_crypto2, algorithm.ivBits);
  return result;
};
var getEncryptParams = (algorithm, key, data) => {
  return [
    algorithm === "aes-128-ctr" ? { name: "AES-CTR", counter: key.iv, length: 128 } : { name: "AES-CBC", iv: key.iv },
    key.key,
    typeof data === "string" ? stringToBuffer(data) : data
  ];
};
var encrypt = async (_crypto2, password, options, data) => {
  const key = await generateKey(_crypto2, password, options);
  const encrypted = await _crypto2.subtle.encrypt(...getEncryptParams(options.algorithm, key, data));
  return { encrypted: new Uint8Array(encrypted), key };
};
var decrypt = async (_crypto2, password, options, data) => {
  const key = await generateKey(_crypto2, password, options);
  const decrypted = await _crypto2.subtle.decrypt(...getEncryptParams(options.algorithm, key, data));
  return bufferToString(new Uint8Array(decrypted));
};
var hmacWithPassword = async (_crypto2, password, options, data) => {
  const key = await generateKey(_crypto2, password, { ...options, hmac: true });
  const textBuffer = stringToBuffer(data);
  const signed = await _crypto2.subtle.sign({ name: "HMAC" }, key.key, textBuffer);
  const digest = base64urlEncode(new Uint8Array(signed));
  return { digest, salt: key.salt };
};
var normalizePassword = (password) => {
  if (typeof password === "string" || password instanceof Uint8Array)
    return { encryption: password, integrity: password };
  if ("secret" in password)
    return { id: password.id, encryption: password.secret, integrity: password.secret };
  return { id: password.id, encryption: password.encryption, integrity: password.integrity };
};
var seal = async (_crypto2, object, password, options) => {
  if (!password)
    throw new Error("Empty password");
  const opts = clone(options);
  const now = Date.now() + (opts.localtimeOffsetMsec || 0);
  const objectString = JSON.stringify(object);
  const pass = normalizePassword(password);
  const { id = "", encryption, integrity } = pass;
  if (id && !/^\w+$/.test(id))
    throw new Error("Invalid password id");
  const { encrypted, key } = await encrypt(_crypto2, encryption, opts.encryption, objectString);
  const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));
  const iv = base64urlEncode(key.iv);
  const expiration = opts.ttl ? now + opts.ttl : "";
  const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;
  const mac = await hmacWithPassword(_crypto2, integrity, opts.integrity, macBaseString);
  const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;
  return sealed;
};
var fixedTimeComparison = (a, b3) => {
  let mismatch = a.length === b3.length ? 0 : 1;
  if (mismatch)
    b3 = a;
  for (let i2 = 0; i2 < a.length; i2 += 1)
    mismatch |= a.charCodeAt(i2) ^ b3.charCodeAt(i2);
  return mismatch === 0;
};
var unseal = async (_crypto2, sealed, password, options) => {
  if (!password)
    throw new Error("Empty password");
  const opts = clone(options);
  const now = Date.now() + (opts.localtimeOffsetMsec || 0);
  const parts = sealed.split("*");
  if (parts.length !== 8)
    throw new Error("Incorrect number of sealed components");
  const prefix = parts[0];
  let passwordId = parts[1];
  const encryptionSalt = parts[2];
  const encryptionIv = parts[3];
  const encryptedB64 = parts[4];
  const expiration = parts[5];
  const hmacSalt = parts[6];
  const hmac = parts[7];
  const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;
  if (macPrefix !== prefix)
    throw new Error("Wrong mac prefix");
  if (expiration) {
    if (!/^\d+$/.test(expiration))
      throw new Error("Invalid expiration");
    const exp = Number.parseInt(expiration, 10);
    if (exp <= now - opts.timestampSkewSec * 1e3)
      throw new Error("Expired seal");
  }
  let pass = "";
  passwordId = passwordId || "default";
  if (typeof password === "string" || password instanceof Uint8Array)
    pass = password;
  else if (passwordId in password) {
    pass = password[passwordId];
  } else {
    throw new Error(`Cannot find password: ${passwordId}`);
  }
  pass = normalizePassword(pass);
  const macOptions = opts.integrity;
  macOptions.salt = hmacSalt;
  const mac = await hmacWithPassword(_crypto2, pass.integrity, macOptions, macBaseString);
  if (!fixedTimeComparison(mac.digest, hmac))
    throw new Error("Bad hmac value");
  const encrypted = base64urlDecode(encryptedB64);
  const decryptOptions = opts.encryption;
  decryptOptions.salt = encryptionSalt;
  decryptOptions.iv = base64urlDecode(encryptionIv);
  const decrypted = await decrypt(_crypto2, pass.encryption, decryptOptions, encrypted);
  if (decrypted)
    return JSON.parse(decrypted);
  return null;
};

// node_modules/.pnpm/node-mock-http@1.0.3/node_modules/node-mock-http/dist/_polyfill/events/nodeless.mjs
var y = 10;
var Y = Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
}())));
var F = (e, t) => e;
var _ = Error;
var Z = Error;
var h = Error;
var w = Error;
var tt = Error;
var R = Symbol.for("nodejs.rejection");
var f = Symbol.for("kCapture");
var M = Symbol.for("events.errorMonitor");
var g = Symbol.for("shapeMode");
var b = Symbol.for("events.maxEventTargetListeners");
var et = Symbol.for("kEnhanceStackBeforeInspector");
var rt = Symbol.for("nodejs.watermarkData");
var v = Symbol.for("kAsyncResource");
var nt = Symbol.for("kFirstEventParam");
var S = Symbol.for("kResistStopPropagation");
var W = Symbol.for("events.maxEventTargetListenersWarned");
var _a, _b;
_b = f, _a = g;
var _m = class _m {
  constructor(t) {
    __publicField(this, "_events");
    __publicField(this, "_eventsCount", 0);
    __publicField(this, "_maxListeners", y);
    __publicField(this, _b, false);
    __publicField(this, _a, false);
    this._events === void 0 || this._events === Object.getPrototypeOf(this)._events ? (this._events = { __proto__: null }, this._eventsCount = 0, this[g] = false) : this[g] = true, this._maxListeners = this._maxListeners || void 0, (t == null ? void 0 : t.captureRejections) ? this[f] = !!t.captureRejections : this[f] = _m.prototype[f];
  }
  static get on() {
    return it;
  }
  static get once() {
    return ot;
  }
  static get getEventListeners() {
    return ct;
  }
  static get getMaxListeners() {
    return ut;
  }
  static get addAbortListener() {
    return $;
  }
  static get EventEmitterAsyncResource() {
    return st;
  }
  static get EventEmitter() {
    return _m;
  }
  static setMaxListeners(t = y, ...r) {
    if (r.length === 0) y = t;
    else for (const n of r) if (q(n)) n[b] = t, n[W] = false;
    else if (typeof n.setMaxListeners == "function") n.setMaxListeners(t);
    else throw new h("eventTargets", ["EventEmitter", "EventTarget"], n);
  }
  static listenerCount(t, r) {
    if (typeof t.listenerCount == "function") return t.listenerCount(r);
    _m.prototype.listenerCount.call(t, r);
  }
  static init() {
    throw new Error("EventEmitter.init() is not implemented.");
  }
  static get captureRejections() {
    return this[f];
  }
  static set captureRejections(t) {
    this[f] = t;
  }
  static get defaultMaxListeners() {
    return y;
  }
  static set defaultMaxListeners(t) {
    y = t;
  }
  setMaxListeners(t) {
    return this._maxListeners = t, this;
  }
  getMaxListeners() {
    return j(this);
  }
  emit(t, ...r) {
    var _a2;
    let n = t === "error";
    const s = this._events;
    if (s !== void 0) n && s[M] !== void 0 && this.emit(M, ...r), n = n && s.error === void 0;
    else if (!n) return false;
    if (n) {
      let i2;
      if (r.length > 0 && (i2 = r[0]), i2 instanceof Error) {
        try {
          const a = {};
          (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, a, _m.prototype.emit), Object.defineProperty(i2, et, { __proto__: null, value: Function.prototype.bind(at, this, i2, a), configurable: true });
        } catch {
        }
        throw i2;
      }
      let u;
      try {
        u = F(i2);
      } catch {
        u = i2;
      }
      const l2 = new Z(u);
      throw l2.context = i2, l2;
    }
    const o2 = s[t];
    if (o2 === void 0) return false;
    if (typeof o2 == "function") {
      const i2 = o2.apply(this, r);
      i2 != null && z(this, i2, t, r);
    } else {
      const i2 = o2.length, u = C(o2);
      for (let l2 = 0; l2 < i2; ++l2) {
        const a = u[l2].apply(this, r);
        a != null && z(this, a, t, r);
      }
    }
    return true;
  }
  addListener(t, r) {
    return B(this, t, r, false), this;
  }
  on(t, r) {
    return this.addListener(t, r);
  }
  prependListener(t, r) {
    return B(this, t, r, true), this;
  }
  once(t, r) {
    return this.on(t, G(this, t, r)), this;
  }
  prependOnceListener(t, r) {
    return this.prependListener(t, G(this, t, r)), this;
  }
  removeListener(t, r) {
    const n = this._events;
    if (n === void 0) return this;
    const s = n[t];
    if (s === void 0) return this;
    if (s === r || s.listener === r) this._eventsCount -= 1, this[g] ? n[t] = void 0 : this._eventsCount === 0 ? this._events = { __proto__: null } : (delete n[t], n.removeListener && this.emit("removeListener", t, s.listener || r));
    else if (typeof s != "function") {
      let o2 = -1;
      for (let i2 = s.length - 1; i2 >= 0; i2--) if (s[i2] === r || s[i2].listener === r) {
        o2 = i2;
        break;
      }
      if (o2 < 0) return this;
      o2 === 0 ? s.shift() : mt(s, o2), s.length === 1 && (n[t] = s[0]), n.removeListener !== void 0 && this.emit("removeListener", t, r);
    }
    return this;
  }
  off(t, r) {
    return this.removeListener(t, r);
  }
  removeAllListeners(t) {
    const r = this._events;
    if (r === void 0) return this;
    if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = { __proto__: null }, this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = { __proto__: null } : delete r[t]), this[g] = false, this;
    if (arguments.length === 0) {
      for (const s of Reflect.ownKeys(r)) s !== "removeListener" && this.removeAllListeners(s);
      return this.removeAllListeners("removeListener"), this._events = { __proto__: null }, this._eventsCount = 0, this[g] = false, this;
    }
    const n = r[t];
    if (typeof n == "function") this.removeListener(t, n);
    else if (n !== void 0) for (let s = n.length - 1; s >= 0; s--) this.removeListener(t, n[s]);
    return this;
  }
  listeners(t) {
    return U(this, t, true);
  }
  rawListeners(t) {
    return U(this, t, false);
  }
  eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  }
  listenerCount(t, r) {
    const n = this._events;
    if (n !== void 0) {
      const s = n[t];
      if (typeof s == "function") return r != null ? r === s || r === s.listener ? 1 : 0 : 1;
      if (s !== void 0) {
        if (r != null) {
          let o2 = 0;
          for (let i2 = 0, u = s.length; i2 < u; i2++) (s[i2] === r || s[i2].listener === r) && o2++;
          return o2;
        }
        return s.length;
      }
    }
    return 0;
  }
};
__publicField(_m, "captureRejectionSymbol", R);
__publicField(_m, "errorMonitor", M);
__publicField(_m, "kMaxEventTargetListeners", b);
__publicField(_m, "kMaxEventTargetListenersWarned", W);
__publicField(_m, "usingDomains", false);
var m = _m;
var st = class extends m {
  constructor(t) {
    let r;
    typeof t == "string" ? (r = t, t = void 0) : r = (t == null ? void 0 : t.name) || new.target.name, super(t), this[v] = new EventEmitterReferencingAsyncResource(this, r, t);
  }
  emit(t, ...r) {
    if (this[v] === void 0) throw new _("EventEmitterAsyncResource");
    const { asyncResource: n } = this;
    return Array.prototype.unshift(r, super.emit, this, t), Reflect.apply(n.runInAsyncScope, n, r);
  }
  emitDestroy() {
    if (this[v] === void 0) throw new _("EventEmitterAsyncResource");
    this.asyncResource.emitDestroy();
  }
  get asyncId() {
    if (this[v] === void 0) throw new _("EventEmitterAsyncResource");
    return this.asyncResource.asyncId();
  }
  get triggerAsyncId() {
    if (this[v] === void 0) throw new _("EventEmitterAsyncResource");
    return this.asyncResource.triggerAsyncId();
  }
  get asyncResource() {
    if (this[v] === void 0) throw new _("EventEmitterAsyncResource");
    return this[v];
  }
};
var it = function(e, t, r = {}) {
  const n = r.signal;
  if (n == null ? void 0 : n.aborted) throw new w(void 0, { cause: n == null ? void 0 : n.reason });
  const s = r.highWaterMark ?? r.highWatermark ?? Number.MAX_SAFE_INTEGER, o2 = r.lowWaterMark ?? r.lowWatermark ?? 1, i2 = new K(), u = new K();
  let l2 = false, a = null, p3 = false, d2 = 0;
  const H2 = Object.setPrototypeOf({ next() {
    var _a2;
    if (d2) {
      const c2 = i2.shift();
      return d2--, l2 && d2 < o2 && ((_a2 = e.resume) == null ? void 0 : _a2.call(e), l2 = false), Promise.resolve(P(c2, false));
    }
    if (a) {
      const c2 = Promise.reject(a);
      return a = null, c2;
    }
    return p3 ? L2() : new Promise(function(c2, X2) {
      u.push({ resolve: c2, reject: X2 });
    });
  }, return() {
    return L2();
  }, throw(c2) {
    if (!c2 || !(c2 instanceof Error)) throw new h("EventEmitter.AsyncIterator", "Error", c2);
    A3(c2);
  }, [Symbol.asyncIterator]() {
    return this;
  }, [rt]: { get size() {
    return d2;
  }, get low() {
    return o2;
  }, get high() {
    return s;
  }, get isPaused() {
    return l2;
  } } }, Y), { addEventListener: x2, removeAll: J2 } = vt();
  x2(e, t, r[nt] ? I : function(...c2) {
    return I(c2);
  }), t !== "error" && typeof e.on == "function" && x2(e, "error", A3);
  const T2 = r == null ? void 0 : r.close;
  if (T2 == null ? void 0 : T2.length) for (const c2 of T2) x2(e, c2, L2);
  const Q2 = n ? $(n, V2) : null;
  return H2;
  function V2() {
    A3(new w(void 0, { cause: n == null ? void 0 : n.reason }));
  }
  function I(c2) {
    var _a2;
    u.isEmpty() ? (d2++, !l2 && d2 > s && (l2 = true, (_a2 = e.pause) == null ? void 0 : _a2.call(e)), i2.push(c2)) : u.shift().resolve(P(c2, false));
  }
  function A3(c2) {
    u.isEmpty() ? a = c2 : u.shift().reject(c2), L2();
  }
  function L2() {
    Q2 == null ? void 0 : Q2[Symbol.dispose](), J2(), p3 = true;
    const c2 = P(void 0, true);
    for (; !u.isEmpty(); ) u.shift().resolve(c2);
    return Promise.resolve(c2);
  }
};
var ot = async function(e, t, r = {}) {
  const n = r == null ? void 0 : r.signal;
  if (n == null ? void 0 : n.aborted) throw new w(void 0, { cause: n == null ? void 0 : n.reason });
  return new Promise((s, o2) => {
    const i2 = (p3) => {
      typeof e.removeListener == "function" && e.removeListener(t, u), n != null && E(n, "abort", a), o2(p3);
    }, u = (...p3) => {
      typeof e.removeListener == "function" && e.removeListener("error", i2), n != null && E(n, "abort", a), s(p3);
    }, l2 = { __proto__: null, once: true, [S]: true };
    O(e, t, u, l2), t !== "error" && typeof e.once == "function" && e.once("error", i2);
    function a() {
      E(e, t, u), E(e, "error", i2), o2(new w(void 0, { cause: n == null ? void 0 : n.reason }));
    }
    n != null && O(n, "abort", a, { __proto__: null, once: true, [S]: true });
  });
};
var $ = function(e, t) {
  if (e === void 0) throw new h("signal", "AbortSignal", e);
  let r;
  return e.aborted ? queueMicrotask(() => t()) : (e.addEventListener("abort", t, { __proto__: null, once: true, [S]: true }), r = () => {
    e.removeEventListener("abort", t);
  }), { __proto__: null, [Symbol.dispose]() {
    r == null ? void 0 : r();
  } };
};
var ct = function(e, t) {
  var _a2;
  if (typeof e.listeners == "function") return e.listeners(t);
  if (q(e)) {
    const r = e[kEvents].get(t), n = [];
    let s = r == null ? void 0 : r.next;
    for (; (s == null ? void 0 : s.listener) !== void 0; ) {
      const o2 = ((_a2 = s.listener) == null ? void 0 : _a2.deref) ? s.listener.deref() : s.listener;
      n.push(o2), s = s.next;
    }
    return n;
  }
  throw new h("emitter", ["EventEmitter", "EventTarget"], e);
};
var ut = function(e) {
  if (typeof (e == null ? void 0 : e.getMaxListeners) == "function") return j(e);
  if (e == null ? void 0 : e[b]) return e[b];
  throw new h("emitter", ["EventEmitter", "EventTarget"], e);
};
var D = 2048;
var k = D - 1;
var N = class {
  constructor() {
    __publicField(this, "bottom");
    __publicField(this, "top");
    __publicField(this, "list");
    __publicField(this, "next");
    this.bottom = 0, this.top = 0, this.list = new Array(D), this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & k) === this.bottom;
  }
  push(t) {
    this.list[this.top] = t, this.top = this.top + 1 & k;
  }
  shift() {
    const t = this.list[this.bottom];
    return t === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & k, t);
  }
};
var K = class {
  constructor() {
    __publicField(this, "head");
    __publicField(this, "tail");
    this.head = this.tail = new N();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(t) {
    this.head.isFull() && (this.head = this.head.next = new N()), this.head.push(t);
  }
  shift() {
    const t = this.tail, r = t.shift();
    return t.isEmpty() && t.next !== null && (this.tail = t.next, t.next = null), r;
  }
};
function q(e) {
  return typeof (e == null ? void 0 : e.addEventListener) == "function";
}
function z(e, t, r, n) {
  if (e[f]) try {
    const s = t.then;
    typeof s == "function" && s.call(t, void 0, function(o2) {
      process.nextTick(lt, e, o2, r, n);
    });
  } catch (s) {
    e.emit("error", s);
  }
}
function lt(e, t, r, n) {
  if (typeof e[R] == "function") e[R](t, r, ...n);
  else {
    const s = e[f];
    try {
      e[f] = false, e.emit("error", t);
    } finally {
      e[f] = s;
    }
  }
}
function j(e) {
  return e._maxListeners === void 0 ? y : e._maxListeners;
}
function at(e, t) {
  let r = "";
  try {
    const { name: o2 } = this.constructor;
    o2 !== "EventEmitter" && (r = ` on ${o2} instance`);
  } catch {
  }
  const n = `
Emitted 'error' event${r} at:
`, s = (t.stack || "").split(`
`).slice(1);
  return e.stack + n + s.join(`
`);
}
function B(e, t, r, n) {
  let s, o2, i2;
  if (o2 = e._events, o2 === void 0 ? (o2 = e._events = { __proto__: null }, e._eventsCount = 0) : (o2.newListener !== void 0 && (e.emit("newListener", t, r.listener ?? r), o2 = e._events), i2 = o2[t]), i2 === void 0) o2[t] = r, ++e._eventsCount;
  else if (typeof i2 == "function" ? i2 = o2[t] = n ? [r, i2] : [i2, r] : n ? i2.unshift(r) : i2.push(r), s = j(e), s > 0 && i2.length > s && !i2.warned) {
    i2.warned = true;
    const u = new tt(`Possible EventEmitter memory leak detected. ${i2.length} ${String(t)} listeners added to ${F(e)}. MaxListeners is ${s}. Use emitter.setMaxListeners() to increase limit`, { name: "MaxListenersExceededWarning", emitter: e, type: t, count: i2.length });
    process.emitWarning(u);
  }
  return e;
}
function ft() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function G(e, t, r) {
  const n = { fired: false, wrapFn: void 0, target: e, type: t, listener: r }, s = ft.bind(n);
  return s.listener = r, n.wrapFn = s, s;
}
function U(e, t, r) {
  const n = e._events;
  if (n === void 0) return [];
  const s = n[t];
  return s === void 0 ? [] : typeof s == "function" ? r ? [s.listener || s] : [s] : r ? ht(s) : C(s);
}
function C(e) {
  switch (e.length) {
    case 2:
      return [e[0], e[1]];
    case 3:
      return [e[0], e[1], e[2]];
    case 4:
      return [e[0], e[1], e[2], e[3]];
    case 5:
      return [e[0], e[1], e[2], e[3], e[4]];
    case 6:
      return [e[0], e[1], e[2], e[3], e[4], e[5]];
  }
  return Array.prototype.slice.call(e);
}
function ht(e) {
  const t = C(e);
  for (let r = 0; r < t.length; ++r) {
    const n = t[r].listener;
    typeof n == "function" && (t[r] = n);
  }
  return t;
}
function P(e, t) {
  return { value: e, done: t };
}
function E(e, t, r, n) {
  if (typeof e.removeListener == "function") e.removeListener(t, r);
  else if (typeof e.removeEventListener == "function") e.removeEventListener(t, r, n);
  else throw new h("emitter", "EventEmitter", e);
}
function O(e, t, r, n) {
  if (typeof e.on == "function") (n == null ? void 0 : n.once) ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function") e.addEventListener(t, r, n);
  else throw new h("emitter", "EventEmitter", e);
}
function vt() {
  const e = [];
  return { addEventListener(t, r, n, s) {
    O(t, r, n, s), Array.prototype.push(e, [t, r, n, s]);
  }, removeAll() {
    for (; e.length > 0; ) Reflect.apply(E, void 0, e.pop());
  } };
}
function mt(e, t) {
  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
  e.pop();
}

// node_modules/.pnpm/node-mock-http@1.0.3/node_modules/node-mock-http/dist/_polyfill/buffer/nodeless.mjs
var d = [];
var y2 = [];
var ot2 = typeof Uint8Array > "u" ? Array : Uint8Array;
var L = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (let t = 0, e = L.length; t < e; ++t) d[t] = L[t], y2[L.charCodeAt(t)] = t;
y2[45] = 62, y2[95] = 63;
function rt2(t) {
  const e = t.length;
  if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  let n = t.indexOf("=");
  n === -1 && (n = e);
  const o2 = n === e ? 0 : 4 - n % 4;
  return [n, o2];
}
function it2(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function ft2(t) {
  let e;
  const n = rt2(t), o2 = n[0], r = n[1], i2 = new ot2(it2(t, o2, r));
  let u = 0;
  const h2 = r > 0 ? o2 - 4 : o2;
  let c2;
  for (c2 = 0; c2 < h2; c2 += 4) e = y2[t.charCodeAt(c2)] << 18 | y2[t.charCodeAt(c2 + 1)] << 12 | y2[t.charCodeAt(c2 + 2)] << 6 | y2[t.charCodeAt(c2 + 3)], i2[u++] = e >> 16 & 255, i2[u++] = e >> 8 & 255, i2[u++] = e & 255;
  return r === 2 && (e = y2[t.charCodeAt(c2)] << 2 | y2[t.charCodeAt(c2 + 1)] >> 4, i2[u++] = e & 255), r === 1 && (e = y2[t.charCodeAt(c2)] << 10 | y2[t.charCodeAt(c2 + 1)] << 4 | y2[t.charCodeAt(c2 + 2)] >> 2, i2[u++] = e >> 8 & 255, i2[u++] = e & 255), i2;
}
function ut2(t) {
  return d[t >> 18 & 63] + d[t >> 12 & 63] + d[t >> 6 & 63] + d[t & 63];
}
function st2(t, e, n) {
  let o2;
  const r = [];
  for (let i2 = e; i2 < n; i2 += 3) o2 = (t[i2] << 16 & 16711680) + (t[i2 + 1] << 8 & 65280) + (t[i2 + 2] & 255), r.push(ut2(o2));
  return r.join("");
}
function P2(t) {
  let e;
  const n = t.length, o2 = n % 3, r = [], i2 = 16383;
  for (let u = 0, h2 = n - o2; u < h2; u += i2) r.push(st2(t, u, u + i2 > h2 ? h2 : u + i2));
  return o2 === 1 ? (e = t[n - 1], r.push(d[e >> 2] + d[e << 4 & 63] + "==")) : o2 === 2 && (e = (t[n - 2] << 8) + t[n - 1], r.push(d[e >> 10] + d[e >> 4 & 63] + d[e << 2 & 63] + "=")), r.join("");
}
function R2(t, e, n, o2, r) {
  let i2, u;
  const h2 = r * 8 - o2 - 1, c2 = (1 << h2) - 1, l2 = c2 >> 1;
  let s = -7, a = n ? r - 1 : 0;
  const I = n ? -1 : 1;
  let w3 = t[e + a];
  for (a += I, i2 = w3 & (1 << -s) - 1, w3 >>= -s, s += h2; s > 0; ) i2 = i2 * 256 + t[e + a], a += I, s -= 8;
  for (u = i2 & (1 << -s) - 1, i2 >>= -s, s += o2; s > 0; ) u = u * 256 + t[e + a], a += I, s -= 8;
  if (i2 === 0) i2 = 1 - l2;
  else {
    if (i2 === c2) return u ? Number.NaN : (w3 ? -1 : 1) * Number.POSITIVE_INFINITY;
    u = u + Math.pow(2, o2), i2 = i2 - l2;
  }
  return (w3 ? -1 : 1) * u * Math.pow(2, i2 - o2);
}
function F2(t, e, n, o2, r, i2) {
  let u, h2, c2, l2 = i2 * 8 - r - 1;
  const s = (1 << l2) - 1, a = s >> 1, I = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  let w3 = o2 ? 0 : i2 - 1;
  const O2 = o2 ? 1 : -1, nt2 = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), Number.isNaN(e) || e === Number.POSITIVE_INFINITY ? (h2 = Number.isNaN(e) ? 1 : 0, u = s) : (u = Math.floor(Math.log2(e)), e * (c2 = Math.pow(2, -u)) < 1 && (u--, c2 *= 2), e += u + a >= 1 ? I / c2 : I * Math.pow(2, 1 - a), e * c2 >= 2 && (u++, c2 /= 2), u + a >= s ? (h2 = 0, u = s) : u + a >= 1 ? (h2 = (e * c2 - 1) * Math.pow(2, r), u = u + a) : (h2 = e * Math.pow(2, a - 1) * Math.pow(2, r), u = 0)); r >= 8; ) t[n + w3] = h2 & 255, w3 += O2, h2 /= 256, r -= 8;
  for (u = u << r | h2, l2 += r; l2 > 0; ) t[n + w3] = u & 255, w3 += O2, u /= 256, l2 -= 8;
  t[n + w3 - O2] |= nt2 * 128;
}
var k2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
var ht2 = 50;
var N2 = 2147483647;
f2.TYPED_ARRAY_SUPPORT = ct2(), !f2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This environment lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function ct2() {
  try {
    const t = new Uint8Array(1), e = { foo: function() {
      return 42;
    } };
    return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
  } catch {
    return false;
  }
}
Object.defineProperty(f2.prototype, "parent", { enumerable: true, get: function() {
  if (f2.isBuffer(this)) return this.buffer;
} }), Object.defineProperty(f2.prototype, "offset", { enumerable: true, get: function() {
  if (f2.isBuffer(this)) return this.byteOffset;
} });
function m2(t) {
  if (t > N2) throw new RangeError('The value "' + t + '" is invalid for option "size"');
  const e = new Uint8Array(t);
  return Object.setPrototypeOf(e, f2.prototype), e;
}
function f2(t, e, n) {
  if (typeof t == "number") {
    if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
    return S2(t);
  }
  return j2(t, e, n);
}
f2.poolSize = 8192;
function j2(t, e, n) {
  if (typeof t == "string") return lt2(t, e);
  if (ArrayBuffer.isView(t)) return pt(t);
  if (t == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
  if (b2(t, ArrayBuffer) || t && b2(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (b2(t, SharedArrayBuffer) || t && b2(t.buffer, SharedArrayBuffer))) return Y2(t, e, n);
  if (typeof t == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
  const o2 = t.valueOf && t.valueOf();
  if (o2 != null && o2 !== t) return f2.from(o2, e, n);
  const r = gt(t);
  if (r) return r;
  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function") return f2.from(t[Symbol.toPrimitive]("string"), e, n);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
}
f2.from = function(t, e, n) {
  return j2(t, e, n);
}, Object.setPrototypeOf(f2.prototype, Uint8Array.prototype), Object.setPrototypeOf(f2, Uint8Array);
function D2(t) {
  if (typeof t != "number") throw new TypeError('"size" argument must be of type number');
  if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"');
}
function at2(t, e, n) {
  return D2(t), t <= 0 ? m2(t) : e !== void 0 ? typeof n == "string" ? m2(t).fill(e, n) : m2(t).fill(e) : m2(t);
}
f2.alloc = function(t, e, n) {
  return at2(t, e, n);
};
function S2(t) {
  return D2(t), m2(t < 0 ? 0 : x(t) | 0);
}
f2.allocUnsafe = function(t) {
  return S2(t);
}, f2.allocUnsafeSlow = function(t) {
  return S2(t);
};
function lt2(t, e) {
  if ((typeof e != "string" || e === "") && (e = "utf8"), !f2.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
  const n = z2(t, e) | 0;
  let o2 = m2(n);
  const r = o2.write(t, e);
  return r !== n && (o2 = o2.slice(0, r)), o2;
}
function _2(t) {
  const e = t.length < 0 ? 0 : x(t.length) | 0, n = m2(e);
  for (let o2 = 0; o2 < e; o2 += 1) n[o2] = t[o2] & 255;
  return n;
}
function pt(t) {
  if (b2(t, Uint8Array)) {
    const e = new Uint8Array(t);
    return Y2(e.buffer, e.byteOffset, e.byteLength);
  }
  return _2(t);
}
function Y2(t, e, n) {
  if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
  if (t.byteLength < e + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
  let o2;
  return e === void 0 && n === void 0 ? o2 = new Uint8Array(t) : n === void 0 ? o2 = new Uint8Array(t, e) : o2 = new Uint8Array(t, e, n), Object.setPrototypeOf(o2, f2.prototype), o2;
}
function gt(t) {
  if (f2.isBuffer(t)) {
    const e = x(t.length) | 0, n = m2(e);
    return n.length === 0 || t.copy(n, 0, 0, e), n;
  }
  if (t.length !== void 0) return typeof t.length != "number" || M2(t.length) ? m2(0) : _2(t);
  if (t.type === "Buffer" && Array.isArray(t.data)) return _2(t.data);
}
function x(t) {
  if (t >= N2) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N2.toString(16) + " bytes");
  return t | 0;
}
f2.isBuffer = function(t) {
  return t != null && t._isBuffer === true && t !== f2.prototype;
}, f2.compare = function(t, e) {
  if (b2(t, Uint8Array) && (t = f2.from(t, t.offset, t.byteLength)), b2(e, Uint8Array) && (e = f2.from(e, e.offset, e.byteLength)), !f2.isBuffer(t) || !f2.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  if (t === e) return 0;
  let n = t.length, o2 = e.length;
  for (let r = 0, i2 = Math.min(n, o2); r < i2; ++r) if (t[r] !== e[r]) {
    n = t[r], o2 = e[r];
    break;
  }
  return n < o2 ? -1 : o2 < n ? 1 : 0;
}, f2.isEncoding = function(t) {
  switch (String(t).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, f2.concat = function(t, e) {
  if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (t.length === 0) return f2.alloc(0);
  let n;
  if (e === void 0) for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
  const o2 = f2.allocUnsafe(e);
  let r = 0;
  for (n = 0; n < t.length; ++n) {
    let i2 = t[n];
    if (b2(i2, Uint8Array)) r + i2.length > o2.length ? (f2.isBuffer(i2) || (i2 = f2.from(i2.buffer, i2.byteOffset, i2.byteLength)), i2.copy(o2, r)) : Uint8Array.prototype.set.call(o2, i2, r);
    else if (f2.isBuffer(i2)) i2.copy(o2, r);
    else throw new TypeError('"list" argument must be an Array of Buffers');
    r += i2.length;
  }
  return o2;
};
function z2(t, e) {
  if (f2.isBuffer(t)) return t.length;
  if (ArrayBuffer.isView(t) || b2(t, ArrayBuffer)) return t.byteLength;
  if (typeof t != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
  const n = t.length, o2 = arguments.length > 2 && arguments[2] === true;
  if (!o2 && n === 0) return 0;
  let r = false;
  for (; ; ) switch (e) {
    case "ascii":
    case "latin1":
    case "binary":
      return n;
    case "utf8":
    case "utf-8":
      return $2(t).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return n * 2;
    case "hex":
      return n >>> 1;
    case "base64":
      return et2(t).length;
    default: {
      if (r) return o2 ? -1 : $2(t).length;
      e = ("" + e).toLowerCase(), r = true;
    }
  }
}
f2.byteLength = z2;
function yt(t, e, n) {
  let o2 = false;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((n === void 0 || n > this.length) && (n = this.length), n <= 0) || (n >>>= 0, e >>>= 0, n <= e)) return "";
  for (t || (t = "utf8"); ; ) switch (t) {
    case "hex":
      return vt2(this, e, n);
    case "utf8":
    case "utf-8":
      return q2(this, e, n);
    case "ascii":
      return At(this, e, n);
    case "latin1":
    case "binary":
      return Ut(this, e, n);
    case "base64":
      return Bt(this, e, n);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return Rt(this, e, n);
    default: {
      if (o2) throw new TypeError("Unknown encoding: " + t);
      t = (t + "").toLowerCase(), o2 = true;
    }
  }
}
f2.prototype._isBuffer = true;
function B2(t, e, n) {
  const o2 = t[e];
  t[e] = t[n], t[n] = o2;
}
f2.prototype.swap16 = function() {
  const t = this.length;
  if (t % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (let e = 0; e < t; e += 2) B2(this, e, e + 1);
  return this;
}, f2.prototype.swap32 = function() {
  const t = this.length;
  if (t % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (let e = 0; e < t; e += 4) B2(this, e, e + 3), B2(this, e + 1, e + 2);
  return this;
}, f2.prototype.swap64 = function() {
  const t = this.length;
  if (t % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (let e = 0; e < t; e += 8) B2(this, e, e + 7), B2(this, e + 1, e + 6), B2(this, e + 2, e + 5), B2(this, e + 3, e + 4);
  return this;
}, f2.prototype.toString = function() {
  const t = this.length;
  return t === 0 ? "" : arguments.length === 0 ? q2(this, 0, t) : Reflect.apply(yt, this, arguments);
}, f2.prototype.toLocaleString = f2.prototype.toString, f2.prototype.equals = function(t) {
  if (!f2.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
  return this === t ? true : f2.compare(this, t) === 0;
}, f2.prototype.inspect = function() {
  let t = "";
  const e = ht2;
  return t = this.toString("hex", 0, e).replace(/(.{2})/g, "$1 ").trim(), this.length > e && (t += " ... "), "<Buffer " + t + ">";
}, k2 && (f2.prototype[k2] = f2.prototype.inspect), f2.prototype.compare = function(t, e, n, o2, r) {
  if (b2(t, Uint8Array) && (t = f2.from(t, t.offset, t.byteLength)), !f2.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
  if (e === void 0 && (e = 0), n === void 0 && (n = t ? t.length : 0), o2 === void 0 && (o2 = 0), r === void 0 && (r = this.length), e < 0 || n > t.length || o2 < 0 || r > this.length) throw new RangeError("out of range index");
  if (o2 >= r && e >= n) return 0;
  if (o2 >= r) return -1;
  if (e >= n) return 1;
  if (e >>>= 0, n >>>= 0, o2 >>>= 0, r >>>= 0, this === t) return 0;
  let i2 = r - o2, u = n - e;
  const h2 = Math.min(i2, u), c2 = this.slice(o2, r), l2 = t.slice(e, n);
  for (let s = 0; s < h2; ++s) if (c2[s] !== l2[s]) {
    i2 = c2[s], u = l2[s];
    break;
  }
  return i2 < u ? -1 : u < i2 ? 1 : 0;
};
function V(t, e, n, o2, r) {
  if (t.length === 0) return -1;
  if (typeof n == "string" ? (o2 = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, M2(n) && (n = r ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {
    if (r) return -1;
    n = t.length - 1;
  } else if (n < 0) if (r) n = 0;
  else return -1;
  if (typeof e == "string" && (e = f2.from(e, o2)), f2.isBuffer(e)) return e.length === 0 ? -1 : G2(t, e, n, o2, r);
  if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? r ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : G2(t, [e], n, o2, r);
  throw new TypeError("val must be string, number or Buffer");
}
function G2(t, e, n, o2, r) {
  let i2 = 1, u = t.length, h2 = e.length;
  if (o2 !== void 0 && (o2 = String(o2).toLowerCase(), o2 === "ucs2" || o2 === "ucs-2" || o2 === "utf16le" || o2 === "utf-16le")) {
    if (t.length < 2 || e.length < 2) return -1;
    i2 = 2, u /= 2, h2 /= 2, n /= 2;
  }
  function c2(s, a) {
    return i2 === 1 ? s[a] : s.readUInt16BE(a * i2);
  }
  let l2;
  if (r) {
    let s = -1;
    for (l2 = n; l2 < u; l2++) if (c2(t, l2) === c2(e, s === -1 ? 0 : l2 - s)) {
      if (s === -1 && (s = l2), l2 - s + 1 === h2) return s * i2;
    } else s !== -1 && (l2 -= l2 - s), s = -1;
  } else for (n + h2 > u && (n = u - h2), l2 = n; l2 >= 0; l2--) {
    let s = true;
    for (let a = 0; a < h2; a++) if (c2(t, l2 + a) !== c2(e, a)) {
      s = false;
      break;
    }
    if (s) return l2;
  }
  return -1;
}
f2.prototype.includes = function(t, e, n) {
  return this.indexOf(t, e, n) !== -1;
}, f2.prototype.indexOf = function(t, e, n) {
  return V(this, t, e, n, true);
}, f2.prototype.lastIndexOf = function(t, e, n) {
  return V(this, t, e, n, false);
};
function wt(t, e, n, o2) {
  n = Number(n) || 0;
  const r = t.length - n;
  o2 ? (o2 = Number(o2), o2 > r && (o2 = r)) : o2 = r;
  const i2 = e.length;
  o2 > i2 / 2 && (o2 = i2 / 2);
  let u;
  for (u = 0; u < o2; ++u) {
    const h2 = Number.parseInt(e.slice(u * 2, u * 2 + 2), 16);
    if (M2(h2)) return u;
    t[n + u] = h2;
  }
  return u;
}
function dt(t, e, n, o2) {
  return T($2(e, t.length - n), t, n, o2);
}
function bt(t, e, n, o2) {
  return T(Nt(e), t, n, o2);
}
function mt2(t, e, n, o2) {
  return T(et2(e), t, n, o2);
}
function Et(t, e, n, o2) {
  return T(St(e, t.length - n), t, n, o2);
}
f2.prototype.write = function(t, e, n, o2) {
  if (e === void 0) o2 = "utf8", n = this.length, e = 0;
  else if (n === void 0 && typeof e == "string") o2 = e, n = this.length, e = 0;
  else if (Number.isFinite(e)) e = e >>> 0, Number.isFinite(n) ? (n = n >>> 0, o2 === void 0 && (o2 = "utf8")) : (o2 = n, n = void 0);
  else throw new TypeError("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  const r = this.length - e;
  if ((n === void 0 || n > r) && (n = r), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  o2 || (o2 = "utf8");
  let i2 = false;
  for (; ; ) switch (o2) {
    case "hex":
      return wt(this, t, e, n);
    case "utf8":
    case "utf-8":
      return dt(this, t, e, n);
    case "ascii":
    case "latin1":
    case "binary":
      return bt(this, t, e, n);
    case "base64":
      return mt2(this, t, e, n);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return Et(this, t, e, n);
    default: {
      if (i2) throw new TypeError("Unknown encoding: " + o2);
      o2 = ("" + o2).toLowerCase(), i2 = true;
    }
  }
}, f2.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
function Bt(t, e, n) {
  return e === 0 && n === t.length ? P2(t) : P2(t.slice(e, n));
}
function q2(t, e, n) {
  n = Math.min(t.length, n);
  const o2 = [];
  let r = e;
  for (; r < n; ) {
    const i2 = t[r];
    let u = null, h2 = i2 > 239 ? 4 : i2 > 223 ? 3 : i2 > 191 ? 2 : 1;
    if (r + h2 <= n) {
      let c2, l2, s, a;
      switch (h2) {
        case 1: {
          i2 < 128 && (u = i2);
          break;
        }
        case 2: {
          c2 = t[r + 1], (c2 & 192) === 128 && (a = (i2 & 31) << 6 | c2 & 63, a > 127 && (u = a));
          break;
        }
        case 3: {
          c2 = t[r + 1], l2 = t[r + 2], (c2 & 192) === 128 && (l2 & 192) === 128 && (a = (i2 & 15) << 12 | (c2 & 63) << 6 | l2 & 63, a > 2047 && (a < 55296 || a > 57343) && (u = a));
          break;
        }
        case 4:
          c2 = t[r + 1], l2 = t[r + 2], s = t[r + 3], (c2 & 192) === 128 && (l2 & 192) === 128 && (s & 192) === 128 && (a = (i2 & 15) << 18 | (c2 & 63) << 12 | (l2 & 63) << 6 | s & 63, a > 65535 && a < 1114112 && (u = a));
      }
    }
    u === null ? (u = 65533, h2 = 1) : u > 65535 && (u -= 65536, o2.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), o2.push(u), r += h2;
  }
  return It(o2);
}
var W2 = 4096;
function It(t) {
  const e = t.length;
  if (e <= W2) return String.fromCharCode.apply(String, t);
  let n = "", o2 = 0;
  for (; o2 < e; ) n += String.fromCharCode.apply(String, t.slice(o2, o2 += W2));
  return n;
}
function At(t, e, n) {
  let o2 = "";
  n = Math.min(t.length, n);
  for (let r = e; r < n; ++r) o2 += String.fromCharCode(t[r] & 127);
  return o2;
}
function Ut(t, e, n) {
  let o2 = "";
  n = Math.min(t.length, n);
  for (let r = e; r < n; ++r) o2 += String.fromCharCode(t[r]);
  return o2;
}
function vt2(t, e, n) {
  const o2 = t.length;
  (!e || e < 0) && (e = 0), (!n || n < 0 || n > o2) && (n = o2);
  let r = "";
  for (let i2 = e; i2 < n; ++i2) r += _t[t[i2]];
  return r;
}
function Rt(t, e, n) {
  const o2 = t.slice(e, n);
  let r = "";
  for (let i2 = 0; i2 < o2.length - 1; i2 += 2) r += String.fromCharCode(o2[i2] + o2[i2 + 1] * 256);
  return r;
}
f2.prototype.slice = function(t, e) {
  const n = this.length;
  t = Math.trunc(t), e = e === void 0 ? n : Math.trunc(e), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), e < t && (e = t);
  const o2 = this.subarray(t, e);
  return Object.setPrototypeOf(o2, f2.prototype), o2;
};
function p(t, e, n) {
  if (t % 1 !== 0 || t < 0) throw new RangeError("offset is not uint");
  if (t + e > n) throw new RangeError("Trying to access beyond buffer length");
}
f2.prototype.readUintLE = f2.prototype.readUIntLE = function(t, e, n) {
  t = t >>> 0, e = e >>> 0, n || p(t, e, this.length);
  let o2 = this[t], r = 1, i2 = 0;
  for (; ++i2 < e && (r *= 256); ) o2 += this[t + i2] * r;
  return o2;
}, f2.prototype.readUintBE = f2.prototype.readUIntBE = function(t, e, n) {
  t = t >>> 0, e = e >>> 0, n || p(t, e, this.length);
  let o2 = this[t + --e], r = 1;
  for (; e > 0 && (r *= 256); ) o2 += this[t + --e] * r;
  return o2;
}, f2.prototype.readUint8 = f2.prototype.readUInt8 = function(t, e) {
  return t = t >>> 0, e || p(t, 1, this.length), this[t];
}, f2.prototype.readUint16LE = f2.prototype.readUInt16LE = function(t, e) {
  return t = t >>> 0, e || p(t, 2, this.length), this[t] | this[t + 1] << 8;
}, f2.prototype.readUint16BE = f2.prototype.readUInt16BE = function(t, e) {
  return t = t >>> 0, e || p(t, 2, this.length), this[t] << 8 | this[t + 1];
}, f2.prototype.readUint32LE = f2.prototype.readUInt32LE = function(t, e) {
  return t = t >>> 0, e || p(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
}, f2.prototype.readUint32BE = f2.prototype.readUInt32BE = function(t, e) {
  return t = t >>> 0, e || p(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
}, f2.prototype.readBigUInt64LE = E2(function(t) {
  t = t >>> 0, U2(t, "offset");
  const e = this[t], n = this[t + 7];
  (e === void 0 || n === void 0) && v2(t, this.length - 8);
  const o2 = e + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, r = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
  return BigInt(o2) + (BigInt(r) << BigInt(32));
}), f2.prototype.readBigUInt64BE = E2(function(t) {
  t = t >>> 0, U2(t, "offset");
  const e = this[t], n = this[t + 7];
  (e === void 0 || n === void 0) && v2(t, this.length - 8);
  const o2 = e * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], r = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
  return (BigInt(o2) << BigInt(32)) + BigInt(r);
}), f2.prototype.readIntLE = function(t, e, n) {
  t = t >>> 0, e = e >>> 0, n || p(t, e, this.length);
  let o2 = this[t], r = 1, i2 = 0;
  for (; ++i2 < e && (r *= 256); ) o2 += this[t + i2] * r;
  return r *= 128, o2 >= r && (o2 -= Math.pow(2, 8 * e)), o2;
}, f2.prototype.readIntBE = function(t, e, n) {
  t = t >>> 0, e = e >>> 0, n || p(t, e, this.length);
  let o2 = e, r = 1, i2 = this[t + --o2];
  for (; o2 > 0 && (r *= 256); ) i2 += this[t + --o2] * r;
  return r *= 128, i2 >= r && (i2 -= Math.pow(2, 8 * e)), i2;
}, f2.prototype.readInt8 = function(t, e) {
  return t = t >>> 0, e || p(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
}, f2.prototype.readInt16LE = function(t, e) {
  t = t >>> 0, e || p(t, 2, this.length);
  const n = this[t] | this[t + 1] << 8;
  return n & 32768 ? n | 4294901760 : n;
}, f2.prototype.readInt16BE = function(t, e) {
  t = t >>> 0, e || p(t, 2, this.length);
  const n = this[t + 1] | this[t] << 8;
  return n & 32768 ? n | 4294901760 : n;
}, f2.prototype.readInt32LE = function(t, e) {
  return t = t >>> 0, e || p(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
}, f2.prototype.readInt32BE = function(t, e) {
  return t = t >>> 0, e || p(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
}, f2.prototype.readBigInt64LE = E2(function(t) {
  t = t >>> 0, U2(t, "offset");
  const e = this[t], n = this[t + 7];
  (e === void 0 || n === void 0) && v2(t, this.length - 8);
  const o2 = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
  return (BigInt(o2) << BigInt(32)) + BigInt(e + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
}), f2.prototype.readBigInt64BE = E2(function(t) {
  t = t >>> 0, U2(t, "offset");
  const e = this[t], n = this[t + 7];
  (e === void 0 || n === void 0) && v2(t, this.length - 8);
  const o2 = (e << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
  return (BigInt(o2) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
}), f2.prototype.readFloatLE = function(t, e) {
  return t = t >>> 0, e || p(t, 4, this.length), R2(this, t, true, 23, 4);
}, f2.prototype.readFloatBE = function(t, e) {
  return t = t >>> 0, e || p(t, 4, this.length), R2(this, t, false, 23, 4);
}, f2.prototype.readDoubleLE = function(t, e) {
  return t = t >>> 0, e || p(t, 8, this.length), R2(this, t, true, 52, 8);
}, f2.prototype.readDoubleBE = function(t, e) {
  return t = t >>> 0, e || p(t, 8, this.length), R2(this, t, false, 52, 8);
};
function g2(t, e, n, o2, r, i2) {
  if (!f2.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > r || e < i2) throw new RangeError('"value" argument is out of bounds');
  if (n + o2 > t.length) throw new RangeError("Index out of range");
}
f2.prototype.writeUintLE = f2.prototype.writeUIntLE = function(t, e, n, o2) {
  if (t = +t, e = e >>> 0, n = n >>> 0, !o2) {
    const u = Math.pow(2, 8 * n) - 1;
    g2(this, t, e, n, u, 0);
  }
  let r = 1, i2 = 0;
  for (this[e] = t & 255; ++i2 < n && (r *= 256); ) this[e + i2] = t / r & 255;
  return e + n;
}, f2.prototype.writeUintBE = f2.prototype.writeUIntBE = function(t, e, n, o2) {
  if (t = +t, e = e >>> 0, n = n >>> 0, !o2) {
    const u = Math.pow(2, 8 * n) - 1;
    g2(this, t, e, n, u, 0);
  }
  let r = n - 1, i2 = 1;
  for (this[e + r] = t & 255; --r >= 0 && (i2 *= 256); ) this[e + r] = t / i2 & 255;
  return e + n;
}, f2.prototype.writeUint8 = f2.prototype.writeUInt8 = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 1, 255, 0), this[e] = t & 255, e + 1;
}, f2.prototype.writeUint16LE = f2.prototype.writeUInt16LE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 2, 65535, 0), this[e] = t & 255, this[e + 1] = t >>> 8, e + 2;
}, f2.prototype.writeUint16BE = f2.prototype.writeUInt16BE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 2, 65535, 0), this[e] = t >>> 8, this[e + 1] = t & 255, e + 2;
}, f2.prototype.writeUint32LE = f2.prototype.writeUInt32LE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 4, 4294967295, 0), this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = t & 255, e + 4;
}, f2.prototype.writeUint32BE = f2.prototype.writeUInt32BE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 4, 4294967295, 0), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t & 255, e + 4;
};
function J(t, e, n, o2, r) {
  tt2(e, o2, r, t, n, 7);
  let i2 = Number(e & BigInt(4294967295));
  t[n++] = i2, i2 = i2 >> 8, t[n++] = i2, i2 = i2 >> 8, t[n++] = i2, i2 = i2 >> 8, t[n++] = i2;
  let u = Number(e >> BigInt(32) & BigInt(4294967295));
  return t[n++] = u, u = u >> 8, t[n++] = u, u = u >> 8, t[n++] = u, u = u >> 8, t[n++] = u, n;
}
function X(t, e, n, o2, r) {
  tt2(e, o2, r, t, n, 7);
  let i2 = Number(e & BigInt(4294967295));
  t[n + 7] = i2, i2 = i2 >> 8, t[n + 6] = i2, i2 = i2 >> 8, t[n + 5] = i2, i2 = i2 >> 8, t[n + 4] = i2;
  let u = Number(e >> BigInt(32) & BigInt(4294967295));
  return t[n + 3] = u, u = u >> 8, t[n + 2] = u, u = u >> 8, t[n + 1] = u, u = u >> 8, t[n] = u, n + 8;
}
f2.prototype.writeBigUInt64LE = E2(function(t, e = 0) {
  return J(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
}), f2.prototype.writeBigUInt64BE = E2(function(t, e = 0) {
  return X(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"));
}), f2.prototype.writeIntLE = function(t, e, n, o2) {
  if (t = +t, e = e >>> 0, !o2) {
    const h2 = Math.pow(2, 8 * n - 1);
    g2(this, t, e, n, h2 - 1, -h2);
  }
  let r = 0, i2 = 1, u = 0;
  for (this[e] = t & 255; ++r < n && (i2 *= 256); ) t < 0 && u === 0 && this[e + r - 1] !== 0 && (u = 1), this[e + r] = Math.trunc(t / i2) - u & 255;
  return e + n;
}, f2.prototype.writeIntBE = function(t, e, n, o2) {
  if (t = +t, e = e >>> 0, !o2) {
    const h2 = Math.pow(2, 8 * n - 1);
    g2(this, t, e, n, h2 - 1, -h2);
  }
  let r = n - 1, i2 = 1, u = 0;
  for (this[e + r] = t & 255; --r >= 0 && (i2 *= 256); ) t < 0 && u === 0 && this[e + r + 1] !== 0 && (u = 1), this[e + r] = Math.trunc(t / i2) - u & 255;
  return e + n;
}, f2.prototype.writeInt8 = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[e] = t & 255, e + 1;
}, f2.prototype.writeInt16LE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 2, 32767, -32768), this[e] = t & 255, this[e + 1] = t >>> 8, e + 2;
}, f2.prototype.writeInt16BE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 2, 32767, -32768), this[e] = t >>> 8, this[e + 1] = t & 255, e + 2;
}, f2.prototype.writeInt32LE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 4, 2147483647, -2147483648), this[e] = t & 255, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24, e + 4;
}, f2.prototype.writeInt32BE = function(t, e, n) {
  return t = +t, e = e >>> 0, n || g2(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t & 255, e + 4;
}, f2.prototype.writeBigInt64LE = E2(function(t, e = 0) {
  return J(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
}), f2.prototype.writeBigInt64BE = E2(function(t, e = 0) {
  return X(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function H(t, e, n, o2, r, i2) {
  if (n + o2 > t.length) throw new RangeError("Index out of range");
  if (n < 0) throw new RangeError("Index out of range");
}
function K2(t, e, n, o2, r) {
  return e = +e, n = n >>> 0, r || H(t, e, n, 4), F2(t, e, n, o2, 23, 4), n + 4;
}
f2.prototype.writeFloatLE = function(t, e, n) {
  return K2(this, t, e, true, n);
}, f2.prototype.writeFloatBE = function(t, e, n) {
  return K2(this, t, e, false, n);
};
function Q(t, e, n, o2, r) {
  return e = +e, n = n >>> 0, r || H(t, e, n, 8), F2(t, e, n, o2, 52, 8), n + 8;
}
f2.prototype.writeDoubleLE = function(t, e, n) {
  return Q(this, t, e, true, n);
}, f2.prototype.writeDoubleBE = function(t, e, n) {
  return Q(this, t, e, false, n);
}, f2.prototype.copy = function(t, e, n, o2) {
  if (!f2.isBuffer(t)) throw new TypeError("argument should be a Buffer");
  if (n || (n = 0), !o2 && o2 !== 0 && (o2 = this.length), e >= t.length && (e = t.length), e || (e = 0), o2 > 0 && o2 < n && (o2 = n), o2 === n || t.length === 0 || this.length === 0) return 0;
  if (e < 0) throw new RangeError("targetStart out of bounds");
  if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
  if (o2 < 0) throw new RangeError("sourceEnd out of bounds");
  o2 > this.length && (o2 = this.length), t.length - e < o2 - n && (o2 = t.length - e + n);
  const r = o2 - n;
  return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(e, n, o2) : Uint8Array.prototype.set.call(t, this.subarray(n, o2), e), r;
}, f2.prototype.fill = function(t, e, n, o2) {
  if (typeof t == "string") {
    if (typeof e == "string" ? (o2 = e, e = 0, n = this.length) : typeof n == "string" && (o2 = n, n = this.length), o2 !== void 0 && typeof o2 != "string") throw new TypeError("encoding must be a string");
    if (typeof o2 == "string" && !f2.isEncoding(o2)) throw new TypeError("Unknown encoding: " + o2);
    if (t.length === 1) {
      const i2 = t.charCodeAt(0);
      (o2 === "utf8" && i2 < 128 || o2 === "latin1") && (t = i2);
    }
  } else typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
  if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index");
  if (n <= e) return this;
  e = e >>> 0, n = n === void 0 ? this.length : n >>> 0, t || (t = 0);
  let r;
  if (typeof t == "number") for (r = e; r < n; ++r) this[r] = t;
  else {
    const i2 = f2.isBuffer(t) ? t : f2.from(t, o2), u = i2.length;
    if (u === 0) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
    for (r = 0; r < n - e; ++r) this[r + e] = i2[r % u];
  }
  return this;
};
var A = {};
function C2(t, e, n) {
  A[t] = class extends n {
    constructor() {
      super(), Object.defineProperty(this, "message", { value: Reflect.apply(e, this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
    }
    get code() {
      return t;
    }
    set code(o2) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: o2, writable: true });
    }
    toString() {
      return `${this.name} [${t}]: ${this.message}`;
    }
  };
}
C2("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
  return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
}, RangeError), C2("ERR_INVALID_ARG_TYPE", function(t, e) {
  return `The "${t}" argument must be of type number. Received type ${typeof e}`;
}, TypeError), C2("ERR_OUT_OF_RANGE", function(t, e, n) {
  let o2 = `The value of "${t}" is out of range.`, r = n;
  return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? r = Z2(String(n)) : typeof n == "bigint" && (r = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (r = Z2(r)), r += "n"), o2 += ` It must be ${e}. Received ${r}`, o2;
}, RangeError);
function Z2(t) {
  let e = "", n = t.length;
  const o2 = t[0] === "-" ? 1 : 0;
  for (; n >= o2 + 4; n -= 3) e = `_${t.slice(n - 3, n)}${e}`;
  return `${t.slice(0, n)}${e}`;
}
function Tt(t, e, n) {
  U2(e, "offset"), (t[e] === void 0 || t[e + n] === void 0) && v2(e, t.length - (n + 1));
}
function tt2(t, e, n, o2, r, i2) {
  if (t > n || t < e) {
    const u = typeof e == "bigint" ? "n" : "";
    let h2;
    throw h2 = e === 0 || e === BigInt(0) ? `>= 0${u} and < 2${u} ** ${(i2 + 1) * 8}${u}` : `>= -(2${u} ** ${(i2 + 1) * 8 - 1}${u}) and < 2 ** ${(i2 + 1) * 8 - 1}${u}`, new A.ERR_OUT_OF_RANGE("value", h2, t);
  }
  Tt(o2, r, i2);
}
function U2(t, e) {
  if (typeof t != "number") throw new A.ERR_INVALID_ARG_TYPE(e, "number", t);
}
function v2(t, e, n) {
  throw Math.floor(t) !== t ? (U2(t, n), new A.ERR_OUT_OF_RANGE("offset", "an integer", t)) : e < 0 ? new A.ERR_BUFFER_OUT_OF_BOUNDS() : new A.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${e}`, t);
}
var Ot = /[^\w+/-]/g;
function Lt(t) {
  if (t = t.split("=")[0], t = t.trim().replace(Ot, ""), t.length < 2) return "";
  for (; t.length % 4 !== 0; ) t = t + "=";
  return t;
}
function $2(t, e) {
  e = e || Number.POSITIVE_INFINITY;
  let n;
  const o2 = t.length;
  let r = null;
  const i2 = [];
  for (let u = 0; u < o2; ++u) {
    if (n = t.charCodeAt(u), n > 55295 && n < 57344) {
      if (!r) {
        if (n > 56319) {
          (e -= 3) > -1 && i2.push(239, 191, 189);
          continue;
        } else if (u + 1 === o2) {
          (e -= 3) > -1 && i2.push(239, 191, 189);
          continue;
        }
        r = n;
        continue;
      }
      if (n < 56320) {
        (e -= 3) > -1 && i2.push(239, 191, 189), r = n;
        continue;
      }
      n = (r - 55296 << 10 | n - 56320) + 65536;
    } else r && (e -= 3) > -1 && i2.push(239, 191, 189);
    if (r = null, n < 128) {
      if ((e -= 1) < 0) break;
      i2.push(n);
    } else if (n < 2048) {
      if ((e -= 2) < 0) break;
      i2.push(n >> 6 | 192, n & 63 | 128);
    } else if (n < 65536) {
      if ((e -= 3) < 0) break;
      i2.push(n >> 12 | 224, n >> 6 & 63 | 128, n & 63 | 128);
    } else if (n < 1114112) {
      if ((e -= 4) < 0) break;
      i2.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, n & 63 | 128);
    } else throw new Error("Invalid code point");
  }
  return i2;
}
function Nt(t) {
  const e = [];
  for (let n = 0; n < t.length; ++n) e.push(t.charCodeAt(n) & 255);
  return e;
}
function St(t, e) {
  let n, o2, r;
  const i2 = [];
  for (let u = 0; u < t.length && !((e -= 2) < 0); ++u) n = t.charCodeAt(u), o2 = n >> 8, r = n % 256, i2.push(r, o2);
  return i2;
}
function et2(t) {
  return ft2(Lt(t));
}
function T(t, e, n, o2) {
  let r;
  for (r = 0; r < o2 && !(r + n >= e.length || r >= t.length); ++r) e[r + n] = t[r];
  return r;
}
function b2(t, e) {
  return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
}
function M2(t) {
  return t !== t;
}
var _t = function() {
  const t = "0123456789abcdef", e = Array.from({ length: 256 });
  for (let n = 0; n < 16; ++n) {
    const o2 = n * 16;
    for (let r = 0; r < 16; ++r) e[o2 + r] = t[n] + t[r];
  }
  return e;
}();
function E2(t) {
  return typeof BigInt > "u" ? xt : t;
}
function xt() {
  throw new Error("BigInt not supported");
}

// node_modules/.pnpm/node-mock-http@1.0.3/node_modules/node-mock-http/dist/index.mjs
function o(n) {
  throw new Error(`${n} is not implemented yet!`);
}
var i = class _i extends m {
  constructor(e) {
    super();
    __publicField(this, "__unenv__", {});
    __publicField(this, "readableEncoding", null);
    __publicField(this, "readableEnded", true);
    __publicField(this, "readableFlowing", false);
    __publicField(this, "readableHighWaterMark", 0);
    __publicField(this, "readableLength", 0);
    __publicField(this, "readableObjectMode", false);
    __publicField(this, "readableAborted", false);
    __publicField(this, "readableDidRead", false);
    __publicField(this, "closed", false);
    __publicField(this, "errored", null);
    __publicField(this, "readable", false);
    __publicField(this, "destroyed", false);
  }
  static from(e, t) {
    return new _i(t);
  }
  _read(e) {
  }
  read(e) {
  }
  setEncoding(e) {
    return this;
  }
  pause() {
    return this;
  }
  resume() {
    return this;
  }
  isPaused() {
    return true;
  }
  unpipe(e) {
    return this;
  }
  unshift(e, t) {
  }
  wrap(e) {
    return this;
  }
  push(e, t) {
    return false;
  }
  _destroy(e, t) {
    this.removeAllListeners();
  }
  destroy(e) {
    return this.destroyed = true, this._destroy(e), this;
  }
  pipe(e, t) {
    return {};
  }
  compose(e, t) {
    throw new Error("Method not implemented.");
  }
  [Symbol.asyncDispose]() {
    return this.destroy(), Promise.resolve();
  }
  async *[Symbol.asyncIterator]() {
    throw o("Readable.asyncIterator");
  }
  iterator(e) {
    throw o("Readable.iterator");
  }
  map(e, t) {
    throw o("Readable.map");
  }
  filter(e, t) {
    throw o("Readable.filter");
  }
  forEach(e, t) {
    throw o("Readable.forEach");
  }
  reduce(e, t, r) {
    throw o("Readable.reduce");
  }
  find(e, t) {
    throw o("Readable.find");
  }
  findIndex(e, t) {
    throw o("Readable.findIndex");
  }
  some(e, t) {
    throw o("Readable.some");
  }
  toArray(e) {
    throw o("Readable.toArray");
  }
  every(e, t) {
    throw o("Readable.every");
  }
  flatMap(e, t) {
    throw o("Readable.flatMap");
  }
  drop(e, t) {
    throw o("Readable.drop");
  }
  take(e, t) {
    throw o("Readable.take");
  }
  asIndexedPairs(e) {
    throw o("Readable.asIndexedPairs");
  }
};
var l = class extends m {
  constructor(e) {
    super();
    __publicField(this, "__unenv__", {});
    __publicField(this, "writable", true);
    __publicField(this, "writableEnded", false);
    __publicField(this, "writableFinished", false);
    __publicField(this, "writableHighWaterMark", 0);
    __publicField(this, "writableLength", 0);
    __publicField(this, "writableObjectMode", false);
    __publicField(this, "writableCorked", 0);
    __publicField(this, "closed", false);
    __publicField(this, "errored", null);
    __publicField(this, "writableNeedDrain", false);
    __publicField(this, "writableAborted", false);
    __publicField(this, "destroyed", false);
    __publicField(this, "_data");
    __publicField(this, "_encoding", "utf8");
  }
  pipe(e, t) {
    return {};
  }
  _write(e, t, r) {
    if (this.writableEnded) {
      r && r();
      return;
    }
    if (this._data === void 0) this._data = e;
    else {
      const s = typeof this._data == "string" ? f2.from(this._data, this._encoding || t || "utf8") : this._data, a = typeof e == "string" ? f2.from(e, t || this._encoding || "utf8") : e;
      this._data = f2.concat([s, a]);
    }
    this._encoding = t, r && r();
  }
  _writev(e, t) {
  }
  _destroy(e, t) {
  }
  _final(e) {
  }
  write(e, t, r) {
    const s = typeof t == "string" ? this._encoding : "utf8", a = typeof t == "function" ? t : typeof r == "function" ? r : void 0;
    return this._write(e, s, a), true;
  }
  setDefaultEncoding(e) {
    return this;
  }
  end(e, t, r) {
    const s = typeof e == "function" ? e : typeof t == "function" ? t : typeof r == "function" ? r : void 0;
    if (this.writableEnded) return s && s(), this;
    const a = e === s ? void 0 : e;
    if (a) {
      const u = t === s ? void 0 : t;
      this.write(a, u, s);
    }
    return this.writableEnded = true, this.writableFinished = true, this.emit("close"), this.emit("finish"), this;
  }
  cork() {
  }
  uncork() {
  }
  destroy(e) {
    return this.destroyed = true, delete this._data, this.removeAllListeners(), this;
  }
  compose(e, t) {
    throw new Error("Method not implemented.");
  }
  [Symbol.asyncDispose]() {
    return Promise.resolve();
  }
};
var c = class {
  constructor(e = new i(), t = new l()) {
    __publicField(this, "allowHalfOpen", true);
    __publicField(this, "_destroy");
    Object.assign(this, e), Object.assign(this, t), this._destroy = m3(e._destroy, t._destroy);
  }
};
function _3() {
  return Object.assign(c.prototype, i.prototype), Object.assign(c.prototype, l.prototype), c;
}
function m3(...n) {
  return function(...e) {
    for (const t of n) t(...e);
  };
}
var g3 = _3();
var A2 = class extends g3 {
  constructor(e) {
    super();
    __publicField(this, "__unenv__", {});
    __publicField(this, "bufferSize", 0);
    __publicField(this, "bytesRead", 0);
    __publicField(this, "bytesWritten", 0);
    __publicField(this, "connecting", false);
    __publicField(this, "destroyed", false);
    __publicField(this, "pending", false);
    __publicField(this, "localAddress", "");
    __publicField(this, "localPort", 0);
    __publicField(this, "remoteAddress", "");
    __publicField(this, "remoteFamily", "");
    __publicField(this, "remotePort", 0);
    __publicField(this, "autoSelectFamilyAttemptedAddresses", []);
    __publicField(this, "readyState", "readOnly");
  }
  write(e, t, r) {
    return false;
  }
  connect(e, t, r) {
    return this;
  }
  end(e, t, r) {
    return this;
  }
  setEncoding(e) {
    return this;
  }
  pause() {
    return this;
  }
  resume() {
    return this;
  }
  setTimeout(e, t) {
    return this;
  }
  setNoDelay(e) {
    return this;
  }
  setKeepAlive(e, t) {
    return this;
  }
  address() {
    return {};
  }
  unref() {
    return this;
  }
  ref() {
    return this;
  }
  destroySoon() {
    this.destroy();
  }
  resetAndDestroy() {
    const e = new Error("ERR_SOCKET_CLOSED");
    return e.code = "ERR_SOCKET_CLOSED", this.destroy(e), this;
  }
};
var y3 = class extends i {
  constructor(e) {
    super();
    __publicField(this, "aborted", false);
    __publicField(this, "httpVersion", "1.1");
    __publicField(this, "httpVersionMajor", 1);
    __publicField(this, "httpVersionMinor", 1);
    __publicField(this, "complete", true);
    __publicField(this, "connection");
    __publicField(this, "socket");
    __publicField(this, "headers", {});
    __publicField(this, "trailers", {});
    __publicField(this, "method", "GET");
    __publicField(this, "url", "/");
    __publicField(this, "statusCode", 200);
    __publicField(this, "statusMessage", "");
    __publicField(this, "closed", false);
    __publicField(this, "errored", null);
    __publicField(this, "readable", false);
    this.socket = this.connection = e || new A2();
  }
  get rawHeaders() {
    const e = this.headers, t = [];
    for (const r in e) if (Array.isArray(e[r])) for (const s of e[r]) t.push(r, s);
    else t.push(r, e[r]);
    return t;
  }
  get rawTrailers() {
    return [];
  }
  setTimeout(e, t) {
    return this;
  }
  get headersDistinct() {
    return p2(this.headers);
  }
  get trailersDistinct() {
    return p2(this.trailers);
  }
};
function p2(n) {
  const e = {};
  for (const [t, r] of Object.entries(n)) t && (e[t] = (Array.isArray(r) ? r : [r]).filter(Boolean));
  return e;
}
var w2 = class extends l {
  constructor(e) {
    super();
    __publicField(this, "statusCode", 200);
    __publicField(this, "statusMessage", "");
    __publicField(this, "upgrading", false);
    __publicField(this, "chunkedEncoding", false);
    __publicField(this, "shouldKeepAlive", false);
    __publicField(this, "useChunkedEncodingByDefault", false);
    __publicField(this, "sendDate", false);
    __publicField(this, "finished", false);
    __publicField(this, "headersSent", false);
    __publicField(this, "strictContentLength", false);
    __publicField(this, "connection", null);
    __publicField(this, "socket", null);
    __publicField(this, "req");
    __publicField(this, "_headers", {});
    this.req = e;
  }
  assignSocket(e) {
    e._httpMessage = this, this.socket = e, this.connection = e, this.emit("socket", e), this._flush();
  }
  _flush() {
    this.flushHeaders();
  }
  detachSocket(e) {
  }
  writeContinue(e) {
  }
  writeHead(e, t, r) {
    e && (this.statusCode = e), typeof t == "string" && (this.statusMessage = t, t = void 0);
    const s = r || t;
    if (s && !Array.isArray(s)) for (const a in s) this.setHeader(a, s[a]);
    return this.headersSent = true, this;
  }
  writeProcessing() {
  }
  setTimeout(e, t) {
    return this;
  }
  appendHeader(e, t) {
    e = e.toLowerCase();
    const r = this._headers[e], s = [...Array.isArray(r) ? r : [r], ...Array.isArray(t) ? t : [t]].filter(Boolean);
    return this._headers[e] = s.length > 1 ? s : s[0], this;
  }
  setHeader(e, t) {
    return this._headers[e.toLowerCase()] = t, this;
  }
  setHeaders(e) {
    for (const [t, r] of Object.entries(e)) this.setHeader(t, r);
    return this;
  }
  getHeader(e) {
    return this._headers[e.toLowerCase()];
  }
  getHeaders() {
    return this._headers;
  }
  getHeaderNames() {
    return Object.keys(this._headers);
  }
  hasHeader(e) {
    return e.toLowerCase() in this._headers;
  }
  removeHeader(e) {
    delete this._headers[e.toLowerCase()];
  }
  addTrailers(e) {
  }
  flushHeaders() {
  }
  writeEarlyHints(e, t) {
    typeof t == "function" && t();
  }
};
var E3 = (() => {
  const n = function() {
  };
  return n.prototype = /* @__PURE__ */ Object.create(null), n;
})();

// node_modules/.pnpm/h3@1.15.4/node_modules/h3/dist/index.mjs
function useBase(base, handler) {
  base = withoutTrailingSlash(base);
  if (!base || base === "/") {
    return handler;
  }
  return eventHandler(async (event) => {
    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || "/";
    const _path = event._path || event.node.req.url || "/";
    event._path = withoutBase(event.path || "/", base);
    event.node.req.url = event._path;
    try {
      return await handler(event);
    } finally {
      event._path = event.node.req.url = _path;
    }
  });
}
function hasProp(obj, prop) {
  try {
    return prop in obj;
  } catch {
    return false;
  }
}
var H3Error = class extends Error {
  constructor(message, opts = {}) {
    super(message, opts);
    __publicField(this, "statusCode", 500);
    __publicField(this, "fatal", false);
    __publicField(this, "unhandled", false);
    __publicField(this, "statusMessage");
    __publicField(this, "data");
    __publicField(this, "cause");
    if (opts.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
  toJSON() {
    const obj = {
      message: this.message,
      statusCode: sanitizeStatusCode(this.statusCode, 500)
    };
    if (this.statusMessage) {
      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);
    }
    if (this.data !== void 0) {
      obj.data = this.data;
    }
    return obj;
  }
};
__publicField(H3Error, "__h3_error__", true);
function createError(input) {
  if (typeof input === "string") {
    return new H3Error(input);
  }
  if (isError(input)) {
    return input;
  }
  const err = new H3Error(input.message ?? input.statusMessage ?? "", {
    cause: input.cause || input
  });
  if (hasProp(input, "stack")) {
    try {
      Object.defineProperty(err, "stack", {
        get() {
          return input.stack;
        }
      });
    } catch {
      try {
        err.stack = input.stack;
      } catch {
      }
    }
  }
  if (input.data) {
    err.data = input.data;
  }
  if (input.statusCode) {
    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);
  } else if (input.status) {
    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);
  }
  if (input.statusMessage) {
    err.statusMessage = input.statusMessage;
  } else if (input.statusText) {
    err.statusMessage = input.statusText;
  }
  if (err.statusMessage) {
    const originalMessage = err.statusMessage;
    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);
    if (sanitizedMessage !== originalMessage) {
      console.warn(
        "[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default."
      );
    }
  }
  if (input.fatal !== void 0) {
    err.fatal = input.fatal;
  }
  if (input.unhandled !== void 0) {
    err.unhandled = input.unhandled;
  }
  return err;
}
function sendError(event, error, debug) {
  if (event.handled) {
    return;
  }
  const h3Error = isError(error) ? error : createError(error);
  const responseBody = {
    statusCode: h3Error.statusCode,
    statusMessage: h3Error.statusMessage,
    stack: [],
    data: h3Error.data
  };
  if (debug) {
    responseBody.stack = (h3Error.stack || "").split("\n").map((l2) => l2.trim());
  }
  if (event.handled) {
    return;
  }
  const _code = Number.parseInt(h3Error.statusCode);
  setResponseStatus(event, _code, h3Error.statusMessage);
  event.node.res.setHeader("content-type", MIMES.json);
  event.node.res.end(JSON.stringify(responseBody, void 0, 2));
}
function isError(input) {
  var _a2;
  return ((_a2 = input == null ? void 0 : input.constructor) == null ? void 0 : _a2.__h3_error__) === true;
}
function parse2(multipartBodyBuffer, boundary) {
  let lastline = "";
  let state = 0;
  let buffer = [];
  const allParts = [];
  let currentPartHeaders = [];
  for (let i2 = 0; i2 < multipartBodyBuffer.length; i2++) {
    const prevByte = i2 > 0 ? multipartBodyBuffer[i2 - 1] : null;
    const currByte = multipartBodyBuffer[i2];
    const newLineChar = currByte === 10 || currByte === 13;
    if (!newLineChar) {
      lastline += String.fromCodePoint(currByte);
    }
    const newLineDetected = currByte === 10 && prevByte === 13;
    if (0 === state && newLineDetected) {
      if ("--" + boundary === lastline) {
        state = 1;
      }
      lastline = "";
    } else if (1 === state && newLineDetected) {
      if (lastline.length > 0) {
        const i22 = lastline.indexOf(":");
        if (i22 > 0) {
          const name = lastline.slice(0, i22).toLowerCase();
          const value = lastline.slice(i22 + 1).trim();
          currentPartHeaders.push([name, value]);
        }
      } else {
        state = 2;
        buffer = [];
      }
      lastline = "";
    } else if (2 === state) {
      if (lastline.length > boundary.length + 4) {
        lastline = "";
      }
      if ("--" + boundary === lastline) {
        const j3 = buffer.length - lastline.length;
        const part = buffer.slice(0, j3 - 1);
        allParts.push(process2(part, currentPartHeaders));
        buffer = [];
        currentPartHeaders = [];
        lastline = "";
        state = 3;
      } else {
        buffer.push(currByte);
      }
      if (newLineDetected) {
        lastline = "";
      }
    } else if (3 === state && newLineDetected) {
      state = 1;
    }
  }
  return allParts;
}
function process2(data, headers) {
  var _a2, _b2;
  const dataObj = {};
  const contentDispositionHeader = ((_a2 = headers.find((h2) => h2[0] === "content-disposition")) == null ? void 0 : _a2[1]) || "";
  for (const i2 of contentDispositionHeader.split(";")) {
    const s = i2.split("=");
    if (s.length !== 2) {
      continue;
    }
    const key = (s[0] || "").trim();
    if (key === "name" || key === "filename") {
      const _value = (s[1] || "").trim().replace(/"/g, "");
      dataObj[key] = Buffer.from(_value, "latin1").toString("utf8");
    }
  }
  const contentType = ((_b2 = headers.find((h2) => h2[0] === "content-type")) == null ? void 0 : _b2[1]) || "";
  if (contentType) {
    dataObj.type = contentType;
  }
  dataObj.data = Buffer.from(data);
  return dataObj;
}
async function validateData(data, fn) {
  try {
    const res = await fn(data);
    if (res === false) {
      throw createValidationError();
    }
    if (res === true) {
      return data;
    }
    return res ?? data;
  } catch (error) {
    throw createValidationError(error);
  }
}
function createValidationError(validateError) {
  throw createError({
    status: 400,
    statusMessage: "Validation Error",
    message: (validateError == null ? void 0 : validateError.message) || "Validation Error",
    data: validateError
  });
}
function getQuery2(event) {
  return getQuery(event.path || "");
}
function getValidatedQuery(event, validate) {
  const query = getQuery2(event);
  return validateData(query, validate);
}
function getRouterParams(event, opts = {}) {
  let params = event.context.params || {};
  if (opts.decode) {
    params = { ...params };
    for (const key in params) {
      params[key] = decode(params[key]);
    }
  }
  return params;
}
function getValidatedRouterParams(event, validate, opts = {}) {
  const routerParams = getRouterParams(event, opts);
  return validateData(routerParams, validate);
}
function getRouterParam(event, name, opts = {}) {
  const params = getRouterParams(event, opts);
  return params[name];
}
function getMethod(event, defaultMethod = "GET") {
  return (event.node.req.method || defaultMethod).toUpperCase();
}
function isMethod(event, expected, allowHead) {
  if (allowHead && event.method === "HEAD") {
    return true;
  }
  if (typeof expected === "string") {
    if (event.method === expected) {
      return true;
    }
  } else if (expected.includes(event.method)) {
    return true;
  }
  return false;
}
function assertMethod(event, expected, allowHead) {
  if (!isMethod(event, expected, allowHead)) {
    throw createError({
      statusCode: 405,
      statusMessage: "HTTP method is not allowed."
    });
  }
}
function getRequestHeaders(event) {
  const _headers = {};
  for (const key in event.node.req.headers) {
    const val = event.node.req.headers[key];
    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(", ") : val;
  }
  return _headers;
}
var getHeaders = getRequestHeaders;
function getRequestHeader(event, name) {
  const headers = getRequestHeaders(event);
  const value = headers[name.toLowerCase()];
  return value;
}
var getHeader = getRequestHeader;
function getRequestHost(event, opts = {}) {
  var _a2;
  if (opts.xForwardedHost) {
    const _header = event.node.req.headers["x-forwarded-host"];
    const xForwardedHost = (_a2 = (_header || "").split(",").shift()) == null ? void 0 : _a2.trim();
    if (xForwardedHost) {
      return xForwardedHost;
    }
  }
  return event.node.req.headers.host || "localhost";
}
function getRequestProtocol(event, opts = {}) {
  var _a2;
  if (opts.xForwardedProto !== false && event.node.req.headers["x-forwarded-proto"] === "https") {
    return "https";
  }
  return ((_a2 = event.node.req.connection) == null ? void 0 : _a2.encrypted) ? "https" : "http";
}
var DOUBLE_SLASH_RE = /[/\\]{2,}/g;
function getRequestPath(event) {
  const path = (event.node.req.url || "/").replace(DOUBLE_SLASH_RE, "/");
  return path;
}
function getRequestURL(event, opts = {}) {
  const host = getRequestHost(event, opts);
  const protocol = getRequestProtocol(event, opts);
  const path = (event.node.req.originalUrl || event.path).replace(
    /^[/\\]+/g,
    "/"
  );
  return new URL(path, `${protocol}://${host}`);
}
function toWebRequest(event) {
  var _a2;
  return ((_a2 = event.web) == null ? void 0 : _a2.request) || new Request(getRequestURL(event), {
    // @ts-ignore Undici option
    duplex: "half",
    method: event.method,
    headers: event.headers,
    body: getRequestWebStream(event)
  });
}
function getRequestIP(event, opts = {}) {
  var _a2, _b2;
  if (event.context.clientAddress) {
    return event.context.clientAddress;
  }
  if (opts.xForwardedFor) {
    const xForwardedFor = (_b2 = (_a2 = getRequestHeader(event, "x-forwarded-for")) == null ? void 0 : _a2.split(",").shift()) == null ? void 0 : _b2.trim();
    if (xForwardedFor) {
      return xForwardedFor;
    }
  }
  if (event.node.req.socket.remoteAddress) {
    return event.node.req.socket.remoteAddress;
  }
}
var RawBodySymbol = Symbol.for("h3RawBody");
var ParsedBodySymbol = Symbol.for("h3ParsedBody");
var PayloadMethods$1 = ["PATCH", "POST", "PUT", "DELETE"];
function readRawBody(event, encoding = "utf8") {
  var _a2, _b2;
  assertMethod(event, PayloadMethods$1);
  const _rawBody = event._requestBody || ((_b2 = (_a2 = event.web) == null ? void 0 : _a2.request) == null ? void 0 : _b2.body) || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;
  if (_rawBody) {
    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {
      if (Buffer.isBuffer(_resolved)) {
        return _resolved;
      }
      if (typeof _resolved.pipeTo === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.pipeTo(
            new WritableStream({
              write(chunk) {
                chunks.push(chunk);
              },
              close() {
                resolve(Buffer.concat(chunks));
              },
              abort(reason) {
                reject(reason);
              }
            })
          ).catch(reject);
        });
      } else if (typeof _resolved.pipe === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.on("data", (chunk) => {
            chunks.push(chunk);
          }).on("end", () => {
            resolve(Buffer.concat(chunks));
          }).on("error", reject);
        });
      }
      if (_resolved.constructor === Object) {
        return Buffer.from(JSON.stringify(_resolved));
      }
      if (_resolved instanceof URLSearchParams) {
        return Buffer.from(_resolved.toString());
      }
      if (_resolved instanceof FormData) {
        return new Response(_resolved).bytes().then((uint8arr) => Buffer.from(uint8arr));
      }
      return Buffer.from(_resolved);
    });
    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;
  }
  if (!Number.parseInt(event.node.req.headers["content-length"] || "") && !String(event.node.req.headers["transfer-encoding"] ?? "").split(",").map((e) => e.trim()).filter(Boolean).includes("chunked")) {
    return Promise.resolve(void 0);
  }
  const promise = event.node.req[RawBodySymbol] = new Promise(
    (resolve, reject) => {
      const bodyData = [];
      event.node.req.on("error", (err) => {
        reject(err);
      }).on("data", (chunk) => {
        bodyData.push(chunk);
      }).on("end", () => {
        resolve(Buffer.concat(bodyData));
      });
    }
  );
  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;
  return result;
}
async function readBody(event, options = {}) {
  const request = event.node.req;
  if (hasProp(request, ParsedBodySymbol)) {
    return request[ParsedBodySymbol];
  }
  const contentType = request.headers["content-type"] || "";
  const body = await readRawBody(event);
  let parsed;
  if (contentType === "application/json") {
    parsed = _parseJSON(body, options.strict ?? true);
  } else if (contentType.startsWith("application/x-www-form-urlencoded")) {
    parsed = _parseURLEncodedBody(body);
  } else if (contentType.startsWith("text/")) {
    parsed = body;
  } else {
    parsed = _parseJSON(body, options.strict ?? false);
  }
  request[ParsedBodySymbol] = parsed;
  return parsed;
}
async function readValidatedBody(event, validate) {
  const _body = await readBody(event, { strict: true });
  return validateData(_body, validate);
}
async function readMultipartFormData(event) {
  var _a2;
  const contentType = getRequestHeader(event, "content-type");
  if (!contentType || !contentType.startsWith("multipart/form-data")) {
    return;
  }
  const boundary = (_a2 = contentType.match(/boundary=([^;]*)(;|$)/i)) == null ? void 0 : _a2[1];
  if (!boundary) {
    return;
  }
  const body = await readRawBody(event, false);
  if (!body) {
    return;
  }
  return parse2(body, boundary);
}
async function readFormData(event) {
  return await toWebRequest(event).formData();
}
function getRequestWebStream(event) {
  var _a2, _b2;
  if (!PayloadMethods$1.includes(event.method)) {
    return;
  }
  const bodyStream = ((_b2 = (_a2 = event.web) == null ? void 0 : _a2.request) == null ? void 0 : _b2.body) || event._requestBody;
  if (bodyStream) {
    return bodyStream;
  }
  const _hasRawBody = RawBodySymbol in event.node.req || "rawBody" in event.node.req || "body" in event.node.req || "__unenv__" in event.node.req;
  if (_hasRawBody) {
    return new ReadableStream({
      async start(controller) {
        const _rawBody = await readRawBody(event, false);
        if (_rawBody) {
          controller.enqueue(_rawBody);
        }
        controller.close();
      }
    });
  }
  return new ReadableStream({
    start: (controller) => {
      event.node.req.on("data", (chunk) => {
        controller.enqueue(chunk);
      });
      event.node.req.on("end", () => {
        controller.close();
      });
      event.node.req.on("error", (err) => {
        controller.error(err);
      });
    }
  });
}
function _parseJSON(body = "", strict) {
  if (!body) {
    return void 0;
  }
  try {
    return destr(body, { strict });
  } catch {
    throw createError({
      statusCode: 400,
      statusMessage: "Bad Request",
      message: "Invalid JSON body"
    });
  }
}
function _parseURLEncodedBody(body) {
  const form = new URLSearchParams(body);
  const parsedForm = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of form.entries()) {
    if (hasProp(parsedForm, key)) {
      if (!Array.isArray(parsedForm[key])) {
        parsedForm[key] = [parsedForm[key]];
      }
      parsedForm[key].push(value);
    } else {
      parsedForm[key] = value;
    }
  }
  return parsedForm;
}
function handleCacheHeaders(event, opts) {
  const cacheControls = ["public", ...opts.cacheControls || []];
  let cacheMatched = false;
  if (opts.maxAge !== void 0) {
    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);
  }
  if (opts.modifiedTime) {
    const modifiedTime = new Date(opts.modifiedTime);
    const ifModifiedSince = event.node.req.headers["if-modified-since"];
    event.node.res.setHeader("last-modified", modifiedTime.toUTCString());
    if (ifModifiedSince && new Date(ifModifiedSince) >= modifiedTime) {
      cacheMatched = true;
    }
  }
  if (opts.etag) {
    event.node.res.setHeader("etag", opts.etag);
    const ifNonMatch = event.node.req.headers["if-none-match"];
    if (ifNonMatch === opts.etag) {
      cacheMatched = true;
    }
  }
  event.node.res.setHeader("cache-control", cacheControls.join(", "));
  if (cacheMatched) {
    event.node.res.statusCode = 304;
    if (!event.handled) {
      event.node.res.end();
    }
    return true;
  }
  return false;
}
var MIMES = {
  html: "text/html",
  json: "application/json"
};
var DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(statusMessage = "") {
  return statusMessage.replace(DISALLOWED_STATUS_CHARS, "");
}
function sanitizeStatusCode(statusCode, defaultStatusCode = 200) {
  if (!statusCode) {
    return defaultStatusCode;
  }
  if (typeof statusCode === "string") {
    statusCode = Number.parseInt(statusCode, 10);
  }
  if (statusCode < 100 || statusCode > 999) {
    return defaultStatusCode;
  }
  return statusCode;
}
function getDistinctCookieKey(name, opts) {
  return [name, opts.domain || "", opts.path || "/"].join(";");
}
function parseCookies(event) {
  return parse(event.node.req.headers.cookie || "");
}
function getCookie(event, name) {
  return parseCookies(event)[name];
}
function setCookie(event, name, value, serializeOptions = {}) {
  if (!serializeOptions.path) {
    serializeOptions = { path: "/", ...serializeOptions };
  }
  const newCookie = serialize(name, value, serializeOptions);
  const currentCookies = splitCookiesString(
    event.node.res.getHeader("set-cookie")
  );
  if (currentCookies.length === 0) {
    event.node.res.setHeader("set-cookie", newCookie);
    return;
  }
  const newCookieKey = getDistinctCookieKey(name, serializeOptions);
  event.node.res.removeHeader("set-cookie");
  for (const cookie of currentCookies) {
    const parsed = parseSetCookie(cookie);
    const key = getDistinctCookieKey(parsed.name, parsed);
    if (key === newCookieKey) {
      continue;
    }
    event.node.res.appendHeader("set-cookie", cookie);
  }
  event.node.res.appendHeader("set-cookie", newCookie);
}
function deleteCookie(event, name, serializeOptions) {
  setCookie(event, name, "", {
    ...serializeOptions,
    maxAge: 0
  });
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString.flatMap((c2) => splitCookiesString(c2));
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  const cookiesStrings = [];
  let pos = 0;
  let start;
  let ch;
  let lastComma;
  let nextStart;
  let cookiesSeparatorFound;
  const skipWhitespace = () => {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  };
  const notSpecialChar = () => {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  };
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.slice(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.slice(start));
    }
  }
  return cookiesStrings;
}
function serializeIterableValue(value) {
  switch (typeof value) {
    case "string": {
      return value;
    }
    case "boolean":
    case "number":
    case "bigint":
    case "symbol": {
      return value.toString();
    }
    case "function":
    case "undefined": {
      return void 0;
    }
    case "object": {
      if (value instanceof Uint8Array) {
        return value;
      }
      return JSON.stringify(value);
    }
  }
}
function coerceIterable(iterable) {
  if (typeof iterable === "function") {
    iterable = iterable();
  }
  if (Symbol.iterator in iterable) {
    return iterable[Symbol.iterator]();
  }
  if (Symbol.asyncIterator in iterable) {
    return iterable[Symbol.asyncIterator]();
  }
  return iterable;
}
var defer = typeof setImmediate === "undefined" ? (fn) => fn() : setImmediate;
function send(event, data, type) {
  if (type) {
    defaultContentType(event, type);
  }
  return new Promise((resolve) => {
    defer(() => {
      if (!event.handled) {
        event.node.res.end(data);
      }
      resolve();
    });
  });
}
function sendNoContent(event, code) {
  if (event.handled) {
    return;
  }
  if (!code && event.node.res.statusCode !== 200) {
    code = event.node.res.statusCode;
  }
  const _code = sanitizeStatusCode(code, 204);
  if (_code === 204) {
    event.node.res.removeHeader("content-length");
  }
  event.node.res.writeHead(_code);
  event.node.res.end();
}
function setResponseStatus(event, code, text) {
  if (code) {
    event.node.res.statusCode = sanitizeStatusCode(
      code,
      event.node.res.statusCode
    );
  }
  if (text) {
    event.node.res.statusMessage = sanitizeStatusMessage(text);
  }
}
function getResponseStatus(event) {
  return event.node.res.statusCode;
}
function getResponseStatusText(event) {
  return event.node.res.statusMessage;
}
function defaultContentType(event, type) {
  if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader("content-type")) {
    event.node.res.setHeader("content-type", type);
  }
}
function sendRedirect(event, location, code = 302) {
  event.node.res.statusCode = sanitizeStatusCode(
    code,
    event.node.res.statusCode
  );
  event.node.res.setHeader("location", location);
  const encodedLoc = location.replace(/"/g, "%22");
  const html = `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`;
  return send(event, html, MIMES.html);
}
function getResponseHeaders(event) {
  return event.node.res.getHeaders();
}
function getResponseHeader(event, name) {
  return event.node.res.getHeader(name);
}
function setResponseHeaders(event, headers) {
  for (const [name, value] of Object.entries(headers)) {
    event.node.res.setHeader(
      name,
      value
    );
  }
}
var setHeaders = setResponseHeaders;
function setResponseHeader(event, name, value) {
  event.node.res.setHeader(name, value);
}
var setHeader = setResponseHeader;
function appendResponseHeaders(event, headers) {
  for (const [name, value] of Object.entries(headers)) {
    appendResponseHeader(event, name, value);
  }
}
var appendHeaders = appendResponseHeaders;
function appendResponseHeader(event, name, value) {
  let current = event.node.res.getHeader(name);
  if (!current) {
    event.node.res.setHeader(name, value);
    return;
  }
  if (!Array.isArray(current)) {
    current = [current.toString()];
  }
  event.node.res.setHeader(name, [...current, value]);
}
var appendHeader = appendResponseHeader;
function clearResponseHeaders(event, headerNames) {
  if (headerNames && headerNames.length > 0) {
    for (const name of headerNames) {
      removeResponseHeader(event, name);
    }
  } else {
    for (const [name] of Object.entries(getResponseHeaders(event))) {
      removeResponseHeader(event, name);
    }
  }
}
function removeResponseHeader(event, name) {
  return event.node.res.removeHeader(name);
}
function isStream(data) {
  if (!data || typeof data !== "object") {
    return false;
  }
  if (typeof data.pipe === "function") {
    if (typeof data._read === "function") {
      return true;
    }
    if (typeof data.abort === "function") {
      return true;
    }
  }
  if (typeof data.pipeTo === "function") {
    return true;
  }
  return false;
}
function isWebResponse(data) {
  return typeof Response !== "undefined" && data instanceof Response;
}
function sendStream(event, stream) {
  if (!stream || typeof stream !== "object") {
    throw new Error("[h3] Invalid stream provided.");
  }
  event.node.res._data = stream;
  if (!event.node.res.socket) {
    event._handled = true;
    return Promise.resolve();
  }
  if (hasProp(stream, "pipeTo") && typeof stream.pipeTo === "function") {
    return stream.pipeTo(
      new WritableStream({
        write(chunk) {
          event.node.res.write(chunk);
        }
      })
    ).then(() => {
      event.node.res.end();
    });
  }
  if (hasProp(stream, "pipe") && typeof stream.pipe === "function") {
    return new Promise((resolve, reject) => {
      stream.pipe(event.node.res);
      if (stream.on) {
        stream.on("end", () => {
          event.node.res.end();
          resolve();
        });
        stream.on("error", (error) => {
          reject(error);
        });
      }
      event.node.res.on("close", () => {
        if (stream.abort) {
          stream.abort();
        }
      });
    });
  }
  throw new Error("[h3] Invalid or incompatible stream provided.");
}
var noop = () => {
};
function writeEarlyHints(event, hints, cb = noop) {
  if (!event.node.res.socket) {
    cb();
    return;
  }
  if (typeof hints === "string" || Array.isArray(hints)) {
    hints = { link: hints };
  }
  if (hints.link) {
    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(",");
  }
  const headers = Object.entries(hints).map(
    (e) => [e[0].toLowerCase(), e[1]]
  );
  if (headers.length === 0) {
    cb();
    return;
  }
  let hint = "HTTP/1.1 103 Early Hints";
  if (hints.link) {
    hint += `\r
Link: ${hints.link.join(", ")}`;
  }
  for (const [header, value] of headers) {
    if (header === "link") {
      continue;
    }
    hint += `\r
${header}: ${value}`;
  }
  if (event.node.res.socket) {
    event.node.res.socket.write(
      `${hint}\r
\r
`,
      "utf8",
      cb
    );
  } else {
    cb();
  }
}
function sendWebResponse(event, response) {
  for (const [key, value] of response.headers) {
    if (key === "set-cookie") {
      event.node.res.appendHeader(key, splitCookiesString(value));
    } else {
      event.node.res.setHeader(key, value);
    }
  }
  if (response.status) {
    event.node.res.statusCode = sanitizeStatusCode(
      response.status,
      event.node.res.statusCode
    );
  }
  if (response.statusText) {
    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  }
  if (response.redirected) {
    event.node.res.setHeader("location", response.url);
  }
  if (!response.body) {
    event.node.res.end();
    return;
  }
  return sendStream(event, response.body);
}
function sendIterable(event, iterable, options) {
  const serializer = (options == null ? void 0 : options.serializer) ?? serializeIterableValue;
  const iterator = coerceIterable(iterable);
  return sendStream(
    event,
    new ReadableStream({
      async pull(controller) {
        const { value, done } = await iterator.next();
        if (value !== void 0) {
          const chunk = serializer(value);
          if (chunk !== void 0) {
            controller.enqueue(chunk);
          }
        }
        if (done) {
          controller.close();
        }
      },
      cancel() {
        var _a2;
        (_a2 = iterator.return) == null ? void 0 : _a2.call(iterator);
      }
    })
  );
}
function resolveCorsOptions(options = {}) {
  const defaultOptions = {
    origin: "*",
    methods: "*",
    allowHeaders: "*",
    exposeHeaders: "*",
    credentials: false,
    maxAge: false,
    preflight: {
      statusCode: 204
    }
  };
  return defu(options, defaultOptions);
}
function isPreflightRequest(event) {
  const origin = getRequestHeader(event, "origin");
  const accessControlRequestMethod = getRequestHeader(
    event,
    "access-control-request-method"
  );
  return event.method === "OPTIONS" && !!origin && !!accessControlRequestMethod;
}
function isCorsOriginAllowed(origin, options) {
  const { origin: originOption } = options;
  if (!origin || !originOption || originOption === "*" || originOption === "null") {
    return true;
  }
  if (Array.isArray(originOption)) {
    return originOption.some((_origin) => {
      if (_origin instanceof RegExp) {
        return _origin.test(origin);
      }
      return origin === _origin;
    });
  }
  return originOption(origin);
}
function createOriginHeaders(event, options) {
  const { origin: originOption } = options;
  const origin = getRequestHeader(event, "origin");
  if (!origin || !originOption || originOption === "*") {
    return { "access-control-allow-origin": "*" };
  }
  if (typeof originOption === "string") {
    return { "access-control-allow-origin": originOption, vary: "origin" };
  }
  return isCorsOriginAllowed(origin, options) ? { "access-control-allow-origin": origin, vary: "origin" } : {};
}
function createMethodsHeaders(options) {
  const { methods } = options;
  if (!methods) {
    return {};
  }
  if (methods === "*") {
    return { "access-control-allow-methods": "*" };
  }
  return methods.length > 0 ? { "access-control-allow-methods": methods.join(",") } : {};
}
function createCredentialsHeaders(options) {
  const { credentials } = options;
  if (credentials) {
    return { "access-control-allow-credentials": "true" };
  }
  return {};
}
function createAllowHeaderHeaders(event, options) {
  const { allowHeaders } = options;
  if (!allowHeaders || allowHeaders === "*" || allowHeaders.length === 0) {
    const header = getRequestHeader(event, "access-control-request-headers");
    return header ? {
      "access-control-allow-headers": header,
      vary: "access-control-request-headers"
    } : {};
  }
  return {
    "access-control-allow-headers": allowHeaders.join(","),
    vary: "access-control-request-headers"
  };
}
function createExposeHeaders(options) {
  const { exposeHeaders } = options;
  if (!exposeHeaders) {
    return {};
  }
  if (exposeHeaders === "*") {
    return { "access-control-expose-headers": exposeHeaders };
  }
  return { "access-control-expose-headers": exposeHeaders.join(",") };
}
function appendCorsPreflightHeaders(event, options) {
  appendHeaders(event, createOriginHeaders(event, options));
  appendHeaders(event, createCredentialsHeaders(options));
  appendHeaders(event, createExposeHeaders(options));
  appendHeaders(event, createMethodsHeaders(options));
  appendHeaders(event, createAllowHeaderHeaders(event, options));
}
function appendCorsHeaders(event, options) {
  appendHeaders(event, createOriginHeaders(event, options));
  appendHeaders(event, createCredentialsHeaders(options));
  appendHeaders(event, createExposeHeaders(options));
}
function handleCors(event, options) {
  const _options = resolveCorsOptions(options);
  if (isPreflightRequest(event)) {
    appendCorsPreflightHeaders(event, options);
    sendNoContent(event, _options.preflight.statusCode);
    return true;
  }
  appendCorsHeaders(event, options);
  return false;
}
async function getRequestFingerprint(event, opts = {}) {
  const fingerprint = [];
  if (opts.ip !== false) {
    fingerprint.push(
      getRequestIP(event, { xForwardedFor: opts.xForwardedFor })
    );
  }
  if (opts.method === true) {
    fingerprint.push(event.method);
  }
  if (opts.path === true) {
    fingerprint.push(event.path);
  }
  if (opts.userAgent === true) {
    fingerprint.push(getRequestHeader(event, "user-agent"));
  }
  const fingerprintString = fingerprint.filter(Boolean).join("|");
  if (!fingerprintString) {
    return null;
  }
  if (opts.hash === false) {
    return fingerprintString;
  }
  const buffer = await _crypto.subtle.digest(
    opts.hash || "SHA-1",
    new TextEncoder().encode(fingerprintString)
  );
  const hash = [...new Uint8Array(buffer)].map((b3) => b3.toString(16).padStart(2, "0")).join("");
  return hash;
}
var PayloadMethods = /* @__PURE__ */ new Set(["PATCH", "POST", "PUT", "DELETE"]);
var ignoredHeaders = /* @__PURE__ */ new Set([
  "transfer-encoding",
  "accept-encoding",
  "connection",
  "keep-alive",
  "upgrade",
  "expect",
  "host",
  "accept"
]);
async function proxyRequest(event, target, opts = {}) {
  var _a2, _b2;
  let body;
  let duplex;
  if (PayloadMethods.has(event.method)) {
    if (opts.streamRequest) {
      body = getRequestWebStream(event);
      duplex = "half";
    } else {
      body = await readRawBody(event, false).catch(() => void 0);
    }
  }
  const method = ((_a2 = opts.fetchOptions) == null ? void 0 : _a2.method) || event.method;
  const fetchHeaders = mergeHeaders(
    getProxyRequestHeaders(event, { host: target.startsWith("/") }),
    (_b2 = opts.fetchOptions) == null ? void 0 : _b2.headers,
    opts.headers
  );
  return sendProxy(event, target, {
    ...opts,
    fetchOptions: {
      method,
      body,
      duplex,
      ...opts.fetchOptions,
      headers: fetchHeaders
    }
  });
}
async function sendProxy(event, target, opts = {}) {
  let response;
  try {
    response = await _getFetch(opts.fetch)(target, {
      headers: opts.headers,
      ignoreResponseError: true,
      // make $ofetch.raw transparent
      ...opts.fetchOptions
    });
  } catch (error) {
    throw createError({
      status: 502,
      statusMessage: "Bad Gateway",
      cause: error
    });
  }
  event.node.res.statusCode = sanitizeStatusCode(
    response.status,
    event.node.res.statusCode
  );
  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  const cookies = [];
  for (const [key, value] of response.headers.entries()) {
    if (key === "content-encoding") {
      continue;
    }
    if (key === "content-length") {
      continue;
    }
    if (key === "set-cookie") {
      cookies.push(...splitCookiesString(value));
      continue;
    }
    event.node.res.setHeader(key, value);
  }
  if (cookies.length > 0) {
    event.node.res.setHeader(
      "set-cookie",
      cookies.map((cookie) => {
        if (opts.cookieDomainRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookieDomainRewrite,
            "domain"
          );
        }
        if (opts.cookiePathRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookiePathRewrite,
            "path"
          );
        }
        return cookie;
      })
    );
  }
  if (opts.onResponse) {
    await opts.onResponse(event, response);
  }
  if (response._data !== void 0) {
    return response._data;
  }
  if (event.handled) {
    return;
  }
  if (opts.sendStream === false) {
    const data = new Uint8Array(await response.arrayBuffer());
    return event.node.res.end(data);
  }
  if (response.body) {
    for await (const chunk of response.body) {
      event.node.res.write(chunk);
    }
  }
  return event.node.res.end();
}
function getProxyRequestHeaders(event, opts) {
  const headers = /* @__PURE__ */ Object.create(null);
  const reqHeaders = getRequestHeaders(event);
  for (const name in reqHeaders) {
    if (!ignoredHeaders.has(name) || name === "host" && (opts == null ? void 0 : opts.host)) {
      headers[name] = reqHeaders[name];
    }
  }
  return headers;
}
function fetchWithEvent(event, req, init, options) {
  return _getFetch(options == null ? void 0 : options.fetch)(req, {
    ...init,
    context: (init == null ? void 0 : init.context) || event.context,
    headers: {
      ...getProxyRequestHeaders(event, {
        host: typeof req === "string" && req.startsWith("/")
      }),
      ...init == null ? void 0 : init.headers
    }
  });
}
function _getFetch(_fetch) {
  if (_fetch) {
    return _fetch;
  }
  if (globalThis.fetch) {
    return globalThis.fetch;
  }
  throw new Error(
    "fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js."
  );
}
function rewriteCookieProperty(header, map, property) {
  const _map = typeof map === "string" ? { "*": map } : map;
  return header.replace(
    new RegExp(`(;\\s*${property}=)([^;]+)`, "gi"),
    (match, prefix, previousValue) => {
      let newValue;
      if (previousValue in _map) {
        newValue = _map[previousValue];
      } else if ("*" in _map) {
        newValue = _map["*"];
      } else {
        return match;
      }
      return newValue ? prefix + newValue : "";
    }
  );
}
function mergeHeaders(defaults2, ...inputs) {
  const _inputs = inputs.filter(Boolean);
  if (_inputs.length === 0) {
    return defaults2;
  }
  const merged = new Headers(defaults2);
  for (const input of _inputs) {
    const entries = Array.isArray(input) ? input : typeof input.entries === "function" ? input.entries() : Object.entries(input);
    for (const [key, value] of entries) {
      if (value !== void 0) {
        merged.set(key, value);
      }
    }
  }
  return merged;
}
var getSessionPromise = Symbol("getSession");
var DEFAULT_NAME = "h3";
var DEFAULT_COOKIE = {
  path: "/",
  secure: true,
  httpOnly: true
};
async function useSession(event, config) {
  const sessionName = config.name || DEFAULT_NAME;
  await getSession(event, config);
  const sessionManager = {
    get id() {
      var _a2, _b2;
      return (_b2 = (_a2 = event.context.sessions) == null ? void 0 : _a2[sessionName]) == null ? void 0 : _b2.id;
    },
    get data() {
      var _a2, _b2;
      return ((_b2 = (_a2 = event.context.sessions) == null ? void 0 : _a2[sessionName]) == null ? void 0 : _b2.data) || {};
    },
    update: async (update) => {
      if (!isEvent(event)) {
        throw new Error("[h3] Cannot update read-only session.");
      }
      await updateSession(event, config, update);
      return sessionManager;
    },
    clear: () => {
      if (!isEvent(event)) {
        throw new Error("[h3] Cannot clear read-only session.");
      }
      clearSession(event, config);
      return Promise.resolve(sessionManager);
    }
  };
  return sessionManager;
}
async function getSession(event, config) {
  var _a2;
  const sessionName = config.name || DEFAULT_NAME;
  if (!event.context.sessions) {
    event.context.sessions = /* @__PURE__ */ Object.create(null);
  }
  const existingSession = event.context.sessions[sessionName];
  if (existingSession) {
    return existingSession[getSessionPromise] || existingSession;
  }
  const session = {
    id: "",
    createdAt: 0,
    data: /* @__PURE__ */ Object.create(null)
  };
  event.context.sessions[sessionName] = session;
  let sealedSession;
  if (config.sessionHeader !== false) {
    const headerName = typeof config.sessionHeader === "string" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;
    const headerValue = _getReqHeader(event, headerName);
    if (typeof headerValue === "string") {
      sealedSession = headerValue;
    }
  }
  if (!sealedSession) {
    const cookieHeader = _getReqHeader(event, "cookie");
    if (cookieHeader) {
      sealedSession = parse(cookieHeader + "")[sessionName];
    }
  }
  if (sealedSession) {
    const promise = unsealSession(event, config, sealedSession).catch(() => {
    }).then((unsealed) => {
      Object.assign(session, unsealed);
      delete event.context.sessions[sessionName][getSessionPromise];
      return session;
    });
    event.context.sessions[sessionName][getSessionPromise] = promise;
    await promise;
  }
  if (!session.id) {
    if (!isEvent(event)) {
      throw new Error(
        "Cannot initialize a new session. Make sure using `useSession(event)` in main handler."
      );
    }
    session.id = ((_a2 = config.generateId) == null ? void 0 : _a2.call(config)) ?? (config.crypto || _crypto).randomUUID();
    session.createdAt = Date.now();
    await updateSession(event, config);
  }
  return session;
}
function _getReqHeader(event, name) {
  var _a2, _b2;
  if (event.node) {
    return (_a2 = event.node) == null ? void 0 : _a2.req.headers[name];
  }
  if (event.request) {
    return (_b2 = event.request.headers) == null ? void 0 : _b2.get(name);
  }
  if (event.headers) {
    return event.headers.get(name);
  }
}
async function updateSession(event, config, update) {
  var _a2;
  const sessionName = config.name || DEFAULT_NAME;
  const session = ((_a2 = event.context.sessions) == null ? void 0 : _a2[sessionName]) || await getSession(event, config);
  if (typeof update === "function") {
    update = update(session.data);
  }
  if (update) {
    Object.assign(session.data, update);
  }
  if (config.cookie !== false) {
    const sealed = await sealSession(event, config);
    setCookie(event, sessionName, sealed, {
      ...DEFAULT_COOKIE,
      expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,
      ...config.cookie
    });
  }
  return session;
}
async function sealSession(event, config) {
  var _a2;
  const sessionName = config.name || DEFAULT_NAME;
  const session = ((_a2 = event.context.sessions) == null ? void 0 : _a2[sessionName]) || await getSession(event, config);
  const sealed = await seal(config.crypto || _crypto, session, config.password, {
    ...defaults,
    ttl: config.maxAge ? config.maxAge * 1e3 : 0,
    ...config.seal
  });
  return sealed;
}
async function unsealSession(_event, config, sealed) {
  const unsealed = await unseal(
    config.crypto || _crypto,
    sealed,
    config.password,
    {
      ...defaults,
      ttl: config.maxAge ? config.maxAge * 1e3 : 0,
      ...config.seal
    }
  );
  if (config.maxAge) {
    const age = Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY);
    if (age > config.maxAge * 1e3) {
      throw new Error("Session expired!");
    }
  }
  return unsealed;
}
function clearSession(event, config) {
  var _a2;
  const sessionName = config.name || DEFAULT_NAME;
  if ((_a2 = event.context.sessions) == null ? void 0 : _a2[sessionName]) {
    delete event.context.sessions[sessionName];
  }
  setCookie(event, sessionName, "", {
    ...DEFAULT_COOKIE,
    ...config.cookie
  });
  return Promise.resolve();
}
function formatEventStreamMessage(message) {
  let result = "";
  if (message.id) {
    result += `id: ${message.id}
`;
  }
  if (message.event) {
    result += `event: ${message.event}
`;
  }
  if (typeof message.retry === "number" && Number.isInteger(message.retry)) {
    result += `retry: ${message.retry}
`;
  }
  result += `data: ${message.data}

`;
  return result;
}
function formatEventStreamMessages(messages) {
  let result = "";
  for (const msg of messages) {
    result += formatEventStreamMessage(msg);
  }
  return result;
}
function setEventStreamHeaders(event) {
  const headers = {
    "Content-Type": "text/event-stream",
    "Cache-Control": "private, no-cache, no-store, no-transform, must-revalidate, max-age=0",
    "X-Accel-Buffering": "no"
    // prevent nginx from buffering the response
  };
  if (!isHttp2Request(event)) {
    headers.Connection = "keep-alive";
  }
  setResponseHeaders(event, headers);
}
function isHttp2Request(event) {
  return getHeader(event, ":path") !== void 0 && getHeader(event, ":method") !== void 0;
}
var EventStream = class {
  constructor(event, opts = {}) {
    __publicField(this, "_h3Event");
    __publicField(this, "_transformStream", new TransformStream());
    __publicField(this, "_writer");
    __publicField(this, "_encoder", new TextEncoder());
    __publicField(this, "_writerIsClosed", false);
    __publicField(this, "_paused", false);
    __publicField(this, "_unsentData");
    __publicField(this, "_disposed", false);
    __publicField(this, "_handled", false);
    this._h3Event = event;
    this._writer = this._transformStream.writable.getWriter();
    this._writer.closed.then(() => {
      this._writerIsClosed = true;
    });
    if (opts.autoclose !== false) {
      this._h3Event.node.req.on("close", () => this.close());
    }
  }
  async push(message) {
    if (typeof message === "string") {
      await this._sendEvent({ data: message });
      return;
    }
    if (Array.isArray(message)) {
      if (message.length === 0) {
        return;
      }
      if (typeof message[0] === "string") {
        const msgs = [];
        for (const item of message) {
          msgs.push({ data: item });
        }
        await this._sendEvents(msgs);
        return;
      }
      await this._sendEvents(message);
      return;
    }
    await this._sendEvent(message);
  }
  async _sendEvent(message) {
    if (this._writerIsClosed) {
      return;
    }
    if (this._paused && !this._unsentData) {
      this._unsentData = formatEventStreamMessage(message);
      return;
    }
    if (this._paused) {
      this._unsentData += formatEventStreamMessage(message);
      return;
    }
    await this._writer.write(this._encoder.encode(formatEventStreamMessage(message))).catch();
  }
  async _sendEvents(messages) {
    if (this._writerIsClosed) {
      return;
    }
    const payload = formatEventStreamMessages(messages);
    if (this._paused && !this._unsentData) {
      this._unsentData = payload;
      return;
    }
    if (this._paused) {
      this._unsentData += payload;
      return;
    }
    await this._writer.write(this._encoder.encode(payload)).catch();
  }
  pause() {
    this._paused = true;
  }
  get isPaused() {
    return this._paused;
  }
  async resume() {
    this._paused = false;
    await this.flush();
  }
  async flush() {
    var _a2;
    if (this._writerIsClosed) {
      return;
    }
    if ((_a2 = this._unsentData) == null ? void 0 : _a2.length) {
      await this._writer.write(this._encoder.encode(this._unsentData));
      this._unsentData = void 0;
    }
  }
  /**
   * Close the stream and the connection if the stream is being sent to the client
   */
  async close() {
    if (this._disposed) {
      return;
    }
    if (!this._writerIsClosed) {
      try {
        await this._writer.close();
      } catch {
      }
    }
    if (this._h3Event._handled && this._handled && !this._h3Event.node.res.closed) {
      this._h3Event.node.res.end();
    }
    this._disposed = true;
  }
  /**
   * Triggers callback when the writable stream is closed.
   * It is also triggered after calling the `close()` method.
   */
  onClosed(cb) {
    this._writer.closed.then(cb);
  }
  async send() {
    setEventStreamHeaders(this._h3Event);
    setResponseStatus(this._h3Event, 200);
    this._h3Event._handled = true;
    this._handled = true;
    await sendStream(this._h3Event, this._transformStream.readable);
  }
};
function createEventStream(event, opts) {
  return new EventStream(event, opts);
}
async function serveStatic(event, options) {
  if (event.method !== "GET" && event.method !== "HEAD") {
    if (!options.fallthrough) {
      throw createError({
        statusMessage: "Method Not Allowed",
        statusCode: 405
      });
    }
    return false;
  }
  const originalId = decodePath(
    withLeadingSlash(withoutTrailingSlash(parseURL(event.path).pathname))
  );
  const acceptEncodings = parseAcceptEncoding(
    getRequestHeader(event, "accept-encoding"),
    options.encodings
  );
  if (acceptEncodings.length > 1) {
    setResponseHeader(event, "vary", "accept-encoding");
  }
  let id = originalId;
  let meta;
  const _ids = idSearchPaths(
    originalId,
    acceptEncodings,
    options.indexNames || ["/index.html"]
  );
  for (const _id of _ids) {
    const _meta = await options.getMeta(_id);
    if (_meta) {
      meta = _meta;
      id = _id;
      break;
    }
  }
  if (!meta) {
    if (!options.fallthrough) {
      throw createError({ statusCode: 404 });
    }
    return false;
  }
  if (meta.etag && !getResponseHeader(event, "etag")) {
    setResponseHeader(event, "etag", meta.etag);
  }
  const ifNotMatch = meta.etag && getRequestHeader(event, "if-none-match") === meta.etag;
  if (ifNotMatch) {
    setResponseStatus(event, 304, "Not Modified");
    return send(event, "");
  }
  if (meta.mtime) {
    const mtimeDate = new Date(meta.mtime);
    const ifModifiedSinceH = getRequestHeader(event, "if-modified-since");
    if (ifModifiedSinceH && new Date(ifModifiedSinceH) >= mtimeDate) {
      setResponseStatus(event, 304, "Not Modified");
      return send(event, null);
    }
    if (!getResponseHeader(event, "last-modified")) {
      setResponseHeader(event, "last-modified", mtimeDate.toUTCString());
    }
  }
  if (meta.type && !getResponseHeader(event, "content-type")) {
    setResponseHeader(event, "content-type", meta.type);
  }
  if (meta.encoding && !getResponseHeader(event, "content-encoding")) {
    setResponseHeader(event, "content-encoding", meta.encoding);
  }
  if (meta.size !== void 0 && meta.size > 0 && !getResponseHeader(event, "content-length")) {
    setResponseHeader(event, "content-length", meta.size);
  }
  if (event.method === "HEAD") {
    return send(event, null);
  }
  const contents = await options.getContents(id);
  return isStream(contents) ? sendStream(event, contents) : send(event, contents);
}
function parseAcceptEncoding(header, encodingMap) {
  if (!encodingMap || !header) {
    return [];
  }
  return String(header || "").split(",").map((e) => encodingMap[e.trim()]).filter(Boolean);
}
function idSearchPaths(id, encodings, indexNames) {
  const ids = [];
  for (const suffix of ["", ...indexNames]) {
    for (const encoding of [...encodings, ""]) {
      ids.push(`${id}${suffix}${encoding}`);
    }
  }
  return ids;
}
function defineWebSocket(hooks) {
  return hooks;
}
function defineWebSocketHandler(hooks) {
  return defineEventHandler({
    handler() {
      throw createError({
        statusCode: 426,
        statusMessage: "Upgrade Required"
      });
    },
    websocket: hooks
  });
}
var H3Event = class {
  constructor(req, res) {
    __publicField(this, "__is_event__", true);
    // Context
    __publicField(this, "node");
    // Node
    __publicField(this, "web");
    // Web
    __publicField(this, "context", {});
    // Shared
    // Request
    __publicField(this, "_method");
    __publicField(this, "_path");
    __publicField(this, "_headers");
    __publicField(this, "_requestBody");
    // Response
    __publicField(this, "_handled", false);
    // Hooks
    __publicField(this, "_onBeforeResponseCalled");
    __publicField(this, "_onAfterResponseCalled");
    this.node = { req, res };
  }
  // --- Request ---
  get method() {
    if (!this._method) {
      this._method = (this.node.req.method || "GET").toUpperCase();
    }
    return this._method;
  }
  get path() {
    return this._path || this.node.req.url || "/";
  }
  get headers() {
    if (!this._headers) {
      this._headers = _normalizeNodeHeaders(this.node.req.headers);
    }
    return this._headers;
  }
  // --- Respoonse ---
  get handled() {
    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;
  }
  respondWith(response) {
    return Promise.resolve(response).then(
      (_response) => sendWebResponse(this, _response)
    );
  }
  // --- Utils ---
  toString() {
    return `[${this.method}] ${this.path}`;
  }
  toJSON() {
    return this.toString();
  }
  // --- Deprecated ---
  /** @deprecated Please use `event.node.req` instead. */
  get req() {
    return this.node.req;
  }
  /** @deprecated Please use `event.node.res` instead. */
  get res() {
    return this.node.res;
  }
};
function isEvent(input) {
  return hasProp(input, "__is_event__");
}
function createEvent(req, res) {
  return new H3Event(req, res);
}
function _normalizeNodeHeaders(nodeHeaders) {
  const headers = new Headers();
  for (const [name, value] of Object.entries(nodeHeaders)) {
    if (Array.isArray(value)) {
      for (const item of value) {
        headers.append(name, item);
      }
    } else if (value) {
      headers.set(name, value);
    }
  }
  return headers;
}
function defineEventHandler(handler) {
  if (typeof handler === "function") {
    handler.__is_handler__ = true;
    return handler;
  }
  const _hooks = {
    onRequest: _normalizeArray(handler.onRequest),
    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)
  };
  const _handler = (event) => {
    return _callHandler(event, handler.handler, _hooks);
  };
  _handler.__is_handler__ = true;
  _handler.__resolve__ = handler.handler.__resolve__;
  _handler.__websocket__ = handler.websocket;
  return _handler;
}
function _normalizeArray(input) {
  return input ? Array.isArray(input) ? input : [input] : void 0;
}
async function _callHandler(event, handler, hooks) {
  if (hooks.onRequest) {
    for (const hook of hooks.onRequest) {
      await hook(event);
      if (event.handled) {
        return;
      }
    }
  }
  const body = await handler(event);
  const response = { body };
  if (hooks.onBeforeResponse) {
    for (const hook of hooks.onBeforeResponse) {
      await hook(event, response);
    }
  }
  return response.body;
}
var eventHandler = defineEventHandler;
function defineRequestMiddleware(fn) {
  return fn;
}
function defineResponseMiddleware(fn) {
  return fn;
}
function isEventHandler(input) {
  return hasProp(input, "__is_handler__");
}
function toEventHandler(input, _4, _route) {
  if (!isEventHandler(input)) {
    console.warn(
      "[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.",
      _route && _route !== "/" ? `
     Route: ${_route}` : "",
      `
     Handler: ${input}`
    );
  }
  return input;
}
function dynamicEventHandler(initial) {
  let current = initial;
  const wrapper = eventHandler((event) => {
    if (current) {
      return current(event);
    }
  });
  wrapper.set = (handler) => {
    current = handler;
  };
  return wrapper;
}
function defineLazyEventHandler(factory) {
  let _promise;
  let _resolved;
  const resolveHandler = () => {
    if (_resolved) {
      return Promise.resolve(_resolved);
    }
    if (!_promise) {
      _promise = Promise.resolve(factory()).then((r) => {
        const handler2 = r.default || r;
        if (typeof handler2 !== "function") {
          throw new TypeError(
            "Invalid lazy handler result. It should be a function:",
            handler2
          );
        }
        _resolved = { handler: toEventHandler(r.default || r) };
        return _resolved;
      });
    }
    return _promise;
  };
  const handler = eventHandler((event) => {
    if (_resolved) {
      return _resolved.handler(event);
    }
    return resolveHandler().then((r) => r.handler(event));
  });
  handler.__resolve__ = resolveHandler;
  return handler;
}
var lazyEventHandler = defineLazyEventHandler;
var H3Headers = globalThis.Headers;
var H3Response = globalThis.Response;
function createApp(options = {}) {
  const stack = [];
  const handler = createAppEventHandler(stack, options);
  const resolve = createResolver(stack);
  handler.__resolve__ = resolve;
  const getWebsocket = cachedFn(() => websocketOptions(resolve, options));
  const app = {
    // @ts-expect-error
    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),
    resolve,
    handler,
    stack,
    options,
    get websocket() {
      return getWebsocket();
    }
  };
  return app;
}
function use(app, arg1, arg2, arg3) {
  if (Array.isArray(arg1)) {
    for (const i2 of arg1) {
      use(app, i2, arg2, arg3);
    }
  } else if (Array.isArray(arg2)) {
    for (const i2 of arg2) {
      use(app, arg1, i2, arg3);
    }
  } else if (typeof arg1 === "string") {
    app.stack.push(
      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })
    );
  } else if (typeof arg1 === "function") {
    app.stack.push(normalizeLayer({ ...arg2, handler: arg1 }));
  } else {
    app.stack.push(normalizeLayer({ ...arg1 }));
  }
  return app;
}
function createAppEventHandler(stack, options) {
  const spacing = options.debug ? 2 : void 0;
  return eventHandler(async (event) => {
    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || "/";
    const _reqPath = event._path || event.node.req.url || "/";
    let _layerPath;
    if (options.onRequest) {
      await options.onRequest(event);
    }
    for (const layer of stack) {
      if (layer.route.length > 1) {
        if (!_reqPath.startsWith(layer.route)) {
          continue;
        }
        _layerPath = _reqPath.slice(layer.route.length) || "/";
      } else {
        _layerPath = _reqPath;
      }
      if (layer.match && !layer.match(_layerPath, event)) {
        continue;
      }
      event._path = _layerPath;
      event.node.req.url = _layerPath;
      const val = await layer.handler(event);
      const _body = val === void 0 ? void 0 : await val;
      if (_body !== void 0) {
        const _response = { body: _body };
        if (options.onBeforeResponse) {
          event._onBeforeResponseCalled = true;
          await options.onBeforeResponse(event, _response);
        }
        await handleHandlerResponse(event, _response.body, spacing);
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, _response);
        }
        return;
      }
      if (event.handled) {
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, void 0);
        }
        return;
      }
    }
    if (!event.handled) {
      throw createError({
        statusCode: 404,
        statusMessage: `Cannot find any path matching ${event.path || "/"}.`
      });
    }
    if (options.onAfterResponse) {
      event._onAfterResponseCalled = true;
      await options.onAfterResponse(event, void 0);
    }
  });
}
function createResolver(stack) {
  return async (path) => {
    let _layerPath;
    for (const layer of stack) {
      if (layer.route === "/" && !layer.handler.__resolve__) {
        continue;
      }
      if (!path.startsWith(layer.route)) {
        continue;
      }
      _layerPath = path.slice(layer.route.length) || "/";
      if (layer.match && !layer.match(_layerPath, void 0)) {
        continue;
      }
      let res = { route: layer.route, handler: layer.handler };
      if (res.handler.__resolve__) {
        const _res = await res.handler.__resolve__(_layerPath);
        if (!_res) {
          continue;
        }
        res = {
          ...res,
          ..._res,
          route: joinURL(res.route || "/", _res.route || "/")
        };
      }
      return res;
    }
  };
}
function normalizeLayer(input) {
  let handler = input.handler;
  if (handler.handler) {
    handler = handler.handler;
  }
  if (input.lazy) {
    handler = lazyEventHandler(handler);
  } else if (!isEventHandler(handler)) {
    handler = toEventHandler(handler, void 0, input.route);
  }
  return {
    route: withoutTrailingSlash(input.route),
    match: input.match,
    handler
  };
}
function handleHandlerResponse(event, val, jsonSpace) {
  if (val === null) {
    return sendNoContent(event);
  }
  if (val) {
    if (isWebResponse(val)) {
      return sendWebResponse(event, val);
    }
    if (isStream(val)) {
      return sendStream(event, val);
    }
    if (val.buffer) {
      return send(event, val);
    }
    if (val.arrayBuffer && typeof val.arrayBuffer === "function") {
      return val.arrayBuffer().then((arrayBuffer) => {
        return send(event, Buffer.from(arrayBuffer), val.type);
      });
    }
    if (val instanceof Error) {
      throw createError(val);
    }
    if (typeof val.end === "function") {
      return true;
    }
  }
  const valType = typeof val;
  if (valType === "string") {
    return send(event, val, MIMES.html);
  }
  if (valType === "object" || valType === "boolean" || valType === "number") {
    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);
  }
  if (valType === "bigint") {
    return send(event, val.toString(), MIMES.json);
  }
  throw createError({
    statusCode: 500,
    statusMessage: `[h3] Cannot send ${valType} as response.`
  });
}
function cachedFn(fn) {
  let cache;
  return () => {
    if (!cache) {
      cache = fn();
    }
    return cache;
  };
}
function websocketOptions(evResolver, appOptions) {
  return {
    ...appOptions.websocket,
    async resolve(info) {
      var _a2, _b2;
      const url = ((_a2 = info.request) == null ? void 0 : _a2.url) || info.url || "/";
      const { pathname } = typeof url === "string" ? parseURL(url) : url;
      const resolved = await evResolver(pathname);
      return ((_b2 = resolved == null ? void 0 : resolved.handler) == null ? void 0 : _b2.__websocket__) || {};
    }
  };
}
var RouterMethods = [
  "connect",
  "delete",
  "get",
  "head",
  "options",
  "post",
  "put",
  "trace",
  "patch"
];
function createRouter2(opts = {}) {
  const _router = createRouter({});
  const routes = {};
  let _matcher;
  const router = {};
  const addRoute = (path, handler, method) => {
    let route = routes[path];
    if (!route) {
      routes[path] = route = { path, handlers: {} };
      _router.insert(path, route);
    }
    if (Array.isArray(method)) {
      for (const m4 of method) {
        addRoute(path, handler, m4);
      }
    } else {
      route.handlers[method] = toEventHandler(handler, void 0, path);
    }
    return router;
  };
  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || "all");
  for (const method of RouterMethods) {
    router[method] = (path, handle) => router.add(path, handle, method);
  }
  const matchHandler = (path = "/", method = "get") => {
    const qIndex = path.indexOf("?");
    if (qIndex !== -1) {
      path = path.slice(0, Math.max(0, qIndex));
    }
    const matched = _router.lookup(path);
    if (!matched || !matched.handlers) {
      return {
        error: createError({
          statusCode: 404,
          name: "Not Found",
          statusMessage: `Cannot find any route matching ${path || "/"}.`
        })
      };
    }
    let handler = matched.handlers[method] || matched.handlers.all;
    if (!handler) {
      if (!_matcher) {
        _matcher = toRouteMatcher(_router);
      }
      const _matches = _matcher.matchAll(path).reverse();
      for (const _match of _matches) {
        if (_match.handlers[method]) {
          handler = _match.handlers[method];
          matched.handlers[method] = matched.handlers[method] || handler;
          break;
        }
        if (_match.handlers.all) {
          handler = _match.handlers.all;
          matched.handlers.all = matched.handlers.all || handler;
          break;
        }
      }
    }
    if (!handler) {
      return {
        error: createError({
          statusCode: 405,
          name: "Method Not Allowed",
          statusMessage: `Method ${method} is not allowed on this route.`
        })
      };
    }
    return { matched, handler };
  };
  const isPreemptive = opts.preemptive || opts.preemtive;
  router.handler = eventHandler((event) => {
    const match = matchHandler(
      event.path,
      event.method.toLowerCase()
    );
    if ("error" in match) {
      if (isPreemptive) {
        throw match.error;
      } else {
        return;
      }
    }
    event.context.matchedRoute = match.matched;
    const params = match.matched.params || {};
    event.context.params = params;
    return Promise.resolve(match.handler(event)).then((res) => {
      if (res === void 0 && isPreemptive) {
        return null;
      }
      return res;
    });
  });
  router.handler.__resolve__ = async (path) => {
    path = withLeadingSlash(path);
    const match = matchHandler(path);
    if ("error" in match) {
      return;
    }
    let res = {
      route: match.matched.path,
      handler: match.handler
    };
    if (match.handler.__resolve__) {
      const _res = await match.handler.__resolve__(path);
      if (!_res) {
        return;
      }
      res = { ...res, ..._res };
    }
    return res;
  };
  return router;
}
var defineNodeListener = (handler) => handler;
var defineNodeMiddleware = (middleware) => middleware;
function fromNodeMiddleware(handler) {
  if (isEventHandler(handler)) {
    return handler;
  }
  if (typeof handler !== "function") {
    throw new TypeError(
      "Invalid handler. It should be a function:",
      handler
    );
  }
  return eventHandler((event) => {
    return callNodeListener(
      handler,
      event.node.req,
      event.node.res
    );
  });
}
function toNodeListener(app) {
  const toNodeHandle = async function(req, res) {
    const event = createEvent(req, res);
    try {
      await app.handler(event);
    } catch (_error) {
      const error = createError(_error);
      if (!isError(_error)) {
        error.unhandled = true;
      }
      setResponseStatus(event, error.statusCode, error.statusMessage);
      if (app.options.onError) {
        await app.options.onError(error, event);
      }
      if (event.handled) {
        return;
      }
      if (error.unhandled || error.fatal) {
        console.error("[h3]", error.fatal ? "[fatal]" : "[unhandled]", error);
      }
      if (app.options.onBeforeResponse && !event._onBeforeResponseCalled) {
        await app.options.onBeforeResponse(event, { body: error });
      }
      await sendError(event, error, !!app.options.debug);
      if (app.options.onAfterResponse && !event._onAfterResponseCalled) {
        await app.options.onAfterResponse(event, { body: error });
      }
    }
  };
  return toNodeHandle;
}
function promisifyNodeListener(handler) {
  return function(req, res) {
    return callNodeListener(handler, req, res);
  };
}
function callNodeListener(handler, req, res) {
  const isMiddleware = handler.length > 2;
  return new Promise((resolve, reject) => {
    const next = (err) => {
      if (isMiddleware) {
        res.off("close", next);
        res.off("error", next);
      }
      return err ? reject(createError(err)) : resolve(void 0);
    };
    try {
      const returned = handler(req, res, next);
      if (isMiddleware && returned === void 0) {
        res.once("close", next);
        res.once("error", next);
      } else {
        resolve(returned);
      }
    } catch (error) {
      next(error);
    }
  });
}
function toPlainHandler(app) {
  const handler = (request) => {
    return _handlePlainRequest(app, request);
  };
  return handler;
}
function fromPlainHandler(handler) {
  return eventHandler(async (event) => {
    const res = await handler({
      method: event.method,
      path: event.path,
      headers: Object.fromEntries(event.headers.entries()),
      body: getRequestWebStream(event),
      context: event.context
    });
    setResponseStatus(event, res.status, res.statusText);
    for (const [key, value] of res.headers) {
      setResponseHeader(event, key, value);
    }
    return res.body;
  });
}
async function _handlePlainRequest(app, request) {
  const path = request.path;
  const method = (request.method || "GET").toUpperCase();
  const headers = new Headers(request.headers);
  const nodeReq = new y3();
  const nodeRes = new w2(nodeReq);
  nodeReq.method = method;
  nodeReq.url = path;
  nodeReq.headers = Object.fromEntries(headers.entries());
  const event = createEvent(nodeReq, nodeRes);
  event._method = method;
  event._path = path;
  event._headers = headers;
  if (request.body) {
    event._requestBody = request.body;
  }
  if (request._eventOverrides) {
    Object.assign(event, request._eventOverrides);
  }
  if (request.context) {
    Object.assign(event.context, request.context);
  }
  try {
    await app.handler(event);
  } catch (_error) {
    const error = createError(_error);
    if (!isError(_error)) {
      error.unhandled = true;
    }
    if (app.options.onError) {
      await app.options.onError(error, event);
    }
    if (!event.handled) {
      if (error.unhandled || error.fatal) {
        console.error("[h3]", error.fatal ? "[fatal]" : "[unhandled]", error);
      }
      await sendError(event, error, !!app.options.debug);
    }
  }
  return {
    status: nodeRes.statusCode,
    statusText: nodeRes.statusMessage,
    headers: _normalizeUnenvHeaders(nodeRes._headers),
    body: nodeRes._data
  };
}
function _normalizeUnenvHeaders(input) {
  const headers = [];
  const cookies = [];
  for (const _key in input) {
    const key = _key.toLowerCase();
    if (key === "set-cookie") {
      cookies.push(
        ...splitCookiesString(input["set-cookie"])
      );
      continue;
    }
    const value = input[key];
    if (Array.isArray(value)) {
      for (const _value of value) {
        headers.push([key, _value]);
      }
    } else if (value !== void 0) {
      headers.push([key, String(value)]);
    }
  }
  if (cookies.length > 0) {
    for (const cookie of cookies) {
      headers.push(["set-cookie", cookie]);
    }
  }
  return headers;
}
function toWebHandler(app) {
  const webHandler = (request, context) => {
    return _handleWebRequest(app, request, context);
  };
  return webHandler;
}
function fromWebHandler(handler) {
  return eventHandler((event) => handler(toWebRequest(event), event.context));
}
var nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
async function _handleWebRequest(app, request, context) {
  const url = new URL(request.url);
  const res = await _handlePlainRequest(app, {
    _eventOverrides: {
      web: { request, url }
    },
    context,
    method: request.method,
    path: url.pathname + url.search,
    headers: request.headers,
    body: request.body
  });
  const body = nullBodyResponses.has(res.status) || request.method === "HEAD" ? null : res.body;
  return new Response(body, {
    status: res.status,
    statusText: res.statusText,
    headers: res.headers
  });
}
export {
  H3Error,
  H3Event,
  H3Headers,
  H3Response,
  MIMES,
  appendCorsHeaders,
  appendCorsPreflightHeaders,
  appendHeader,
  appendHeaders,
  appendResponseHeader,
  appendResponseHeaders,
  assertMethod,
  callNodeListener,
  clearResponseHeaders,
  clearSession,
  createApp,
  createAppEventHandler,
  createError,
  createEvent,
  createEventStream,
  createRouter2 as createRouter,
  defaultContentType,
  defineEventHandler,
  defineLazyEventHandler,
  defineNodeListener,
  defineNodeMiddleware,
  defineRequestMiddleware,
  defineResponseMiddleware,
  defineWebSocket,
  defineWebSocketHandler,
  deleteCookie,
  dynamicEventHandler,
  eventHandler,
  fetchWithEvent,
  fromNodeMiddleware,
  fromPlainHandler,
  fromWebHandler,
  getCookie,
  getHeader,
  getHeaders,
  getMethod,
  getProxyRequestHeaders,
  getQuery2 as getQuery,
  getRequestFingerprint,
  getRequestHeader,
  getRequestHeaders,
  getRequestHost,
  getRequestIP,
  getRequestPath,
  getRequestProtocol,
  getRequestURL,
  getRequestWebStream,
  getResponseHeader,
  getResponseHeaders,
  getResponseStatus,
  getResponseStatusText,
  getRouterParam,
  getRouterParams,
  getSession,
  getValidatedQuery,
  getValidatedRouterParams,
  handleCacheHeaders,
  handleCors,
  isCorsOriginAllowed,
  isError,
  isEvent,
  isEventHandler,
  isMethod,
  isPreflightRequest,
  isStream,
  isWebResponse,
  lazyEventHandler,
  parseCookies,
  promisifyNodeListener,
  proxyRequest,
  readBody,
  readFormData,
  readMultipartFormData,
  readRawBody,
  readValidatedBody,
  removeResponseHeader,
  sanitizeStatusCode,
  sanitizeStatusMessage,
  sealSession,
  send,
  sendError,
  sendIterable,
  sendNoContent,
  sendProxy,
  sendRedirect,
  sendStream,
  sendWebResponse,
  serveStatic,
  setCookie,
  setHeader,
  setHeaders,
  setResponseHeader,
  setResponseHeaders,
  setResponseStatus,
  splitCookiesString,
  toEventHandler,
  toNodeListener,
  toPlainHandler,
  toWebHandler,
  toWebRequest,
  unsealSession,
  updateSession,
  use,
  useBase,
  useSession,
  writeEarlyHints
};
/*! Bundled license information:

node-mock-http/dist/_polyfill/buffer/nodeless.mjs:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=h3.js.map
